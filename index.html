<!DOCTYPE html>
<html lang="en">
<!--
    N.I.T.T.A.L.A. Forensic Suite
    Developed by PHANEENDHAR.NITTALA

    Unauthorized copying, distribution, or use of this software,
    in whole or in part, is strictly prohibited. This tool is
    provided for educational and professional use under specific terms.
    All rights reserved.
-->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>N.I.T.T.A.L.A - Forensic Suite v8.0</title> 
    <meta name="description" content="A powerful tool for digital forensics. Analyze files, find hidden data, check passwords, and investigate network logs. Created by Phaneendhar, Nittala.">
    <meta name="keywords" content="forensic tools, free forensic suite, digital forensics, NITTALA, online forensic analysis, file integrity check, hash generator, SHA256 checker, file comparison tool, EXIF metadata viewer, image metadata extraction, steganography detector, hidden data finder, password strength checker, strong password generator, network log analyzer, cyber forensics, digital evidence analysis, security investigation, forensic application, open source forensic tools, digital investigation toolkit">    
   <meta name="google-site-verification" content="IXwGN6cqjcXSTspckCSqspttGgtLi37GKtr9n6fCaFY" />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script src="https://cdn.jsdelivr.net/npm/exifreader@4.13.0/dist/exif-reader.min.js"></script>
    <link rel="icon" href="data:image/svg+xml,%3Csvg%20width%3D%22100%22%20height%3D%22100%22%20viewBox%3D%220%200%20100%20100%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cdefs%3E%3ClinearGradient%20id%3D%22nLogoGradient%22%20x1%3D%220%22%20y1%3D%220%22%20x2%3D%221%22%20y2%3D%221%22%3E%3Cstop%20offset%3D%220%25%22%20stop-color%3D%22%2338BDF8%22%2F%3E%3Cstop%20offset%3D%22100%25%22%20stop-color%3D%22%232563EB%22%2F%3E%3C%2FlinearGradient%3E%3C%2Fdefs%3E%3Crect%20width%3D%22100%22%20height%3D%22100%22%20rx%3D%2220%22%20fill%3D%22%231F2937%22%2F%3E%3Ctext%20x%3D%2250%22%20y%3D%2278%22%20font-family%3D%22sans-serif%22%20font-size%3D%2280%22%20font-weight%3D%22bold%22%20fill%3D%22url(%23nLogoGradient)%22%20text-anchor%3D%22middle%22%3EN%3C%2Ftext%3E%3C%2Fsvg%3E">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://unpkg.com/jspdf-autotable@3.8.2/dist/jspdf.plugin.autotable.js"></script>
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "SoftwareApplication",
      "name": "N.I.T.T.A.L.A. Forensic Suite",
      "description": "A powerful, client-side tool for digital forensics. Analyze files, find hidden data, check passwords, and investigate network logs without uploading any data. Created by Phaneendhar, Nittala.",
      "applicationCategory": "SecurityApplication",
      "operatingSystem": "Any (Web Browser)",
      "author": {
        "@type": "Person",
        "name": "PHANEENDHAR.NITTALA"
      },
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      },
      "keywords": "forensic tool, NITTALA, digital investigation, file analysis, metadata, steganography, client-side, privacy"
    }
    </script>
    <style>
        :root {
            --primary-bg: #0A0F1E;
            --secondary-bg: #101827;
            --card-bg: rgba(20, 28, 48, 0.6);
            --border-color: rgba(63, 131, 248, 0.25);
            --accent-primary: #3F83F8;
            --accent-secondary: #00D1FF;
            --text-primary: #F9FAFB;
            --text-secondary: #B0B9C3;
            --success: #10B981;
            --warning: #F59E0B;
            --danger: #EF4444;
            --diff-color: #EF4444; /* Color for the diff map highlight */
            --trail-color-1: #A78BFA; /* Trail Color 1 (e.g., Purple) */
            --trail-color-2: #F472B6; /* Trail Color 2 (e.g., Pink) */
            --trail-color-3: #7DD3FC; /* Trail Color 3 (e.g., Light Blue) */
            --font-sans: 'Inter', sans-serif;
            --font-mono: 'Roboto Mono', monospace;
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.2), 0 4px 6px -2px rgb(0 0 0 / 0.2);
            --constellation-color-rgb: 63, 131, 248;
        }
        body.light-theme {
            --primary-bg: #F9FAFB;
            --secondary-bg: #FFFFFF;
            --card-bg: rgba(255, 255, 255, 0.8);
            --border-color: #E5E7EB;
            --text-primary: #111827;
            --text-secondary: #4B5563;
            --constellation-color-rgb: 75, 85, 99;
            background-image: linear-gradient(rgba(0, 0, 0, 0.05) 1px, transparent 1px), linear-gradient(90deg, rgba(0, 0, 0, 0.05) 1px, transparent 1px);
        }
        body.light-theme .tool-card { box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.05), 0 2px 4px -2px rgb(0 0 0 / 0.05); }
        body.light-theme #background-canvas {
            opacity: 0.4;
        }
        body.light-theme .output {
            background: #F3F4F6;
            border-color: #E5E7EB;
        }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes spin { to { transform: rotate(360deg); } }
        @keyframes pulse { 
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.7; }
        }
        
        @keyframes text-gradient-pan {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        @keyframes draw-in {
            to {
                stroke-dashoffset: 0;
            }
        }

        @keyframes logo-pulse {
            0%, 100% {
                filter: drop-shadow(0 0 4px var(--accent-primary));
            }
            50% {
                filter: drop-shadow(0 0 15px var(--accent-primary));
            }
        }

        @keyframes glitch-1 {
            0%, 100% { clip-path: inset(50% 50% 50% 50%); }
            20% { clip-path: inset(10% 0 85% 0); }
            40% { clip-path: inset(90% 0 1% 0); }
            60% { clip-path: inset(25% 0 50% 0); }
            80% { clip-path: inset(40% 0 45% 0); }
        }
        @keyframes glitch-2 {
            0%, 100% { clip-path: inset(50% 50% 50% 50%); }
            10% { clip-path: inset(80% 0 5% 0); }
            30% { clip-path: inset(5% 0 90% 0); }
            50% { clip-path: inset(60% 0 30% 0); }
            70% { clip-path: inset(95% 0 2% 0); }
        }

        @keyframes background-pan {
          0% {
            background-position: 0% 0%;
          }
          100% {
            background-position: 100% 100%;
          }
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html { scroll-behavior: smooth; }
        body {
            background-color: var(--primary-bg);
            color: var(--text-primary);
            font-family: var(--font-sans);
            line-height: 1.6;
            background-image: linear-gradient(rgba(63, 131, 248, 0.05) 1px, transparent 1px), linear-gradient(90deg, rgba(63, 131, 248, 0.05) 1px, transparent 1px);
            background-size: 50px 50px;
            animation: background-pan 60s linear infinite;
        }
        #background-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.2;
        }
        .container { width: 100%; max-width: 1600px; margin: 0 auto; padding: 1rem; }
        header {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            margin-bottom: 3rem;
            padding-bottom: 2rem;
            border-bottom: 1px solid var(--border-color); animation: fadeIn 0.8s ease-out;
        }
        .logo-link {
            display: inline-block;
            margin-bottom: 1rem;
            transition: transform 0.3s ease, filter 0.3s ease;
        }
        .logo-link:hover {
            transform: scale(1.05);
            /* The glow effect is now handled by the SVG animation */
        }
        .logo-link img {
            display: block;
        }
        /* --- Animated Logo --- */
        #logo-n {
            overflow: visible; /* Allow glow to extend beyond the viewBox */
        }

        .logo-n-path {
            stroke: var(--accent-secondary);
            fill: transparent;
            stroke-dasharray: 100; /* A value larger than any path length */
            stroke-dashoffset: 100;
            animation: draw-in 1s ease-in-out forwards;
        }

        #logo-n path:nth-child(1) { animation-delay: 0s; }
        #logo-n path:nth-child(2) { animation-delay: 0.2s; }
        #logo-n path:nth-child(3) { animation-delay: 0.4s; }

        .logo-link:hover .logo-n-path {
            stroke: var(--accent-primary);
        }

        .logo-link:hover .logo-n-glow {
            animation: logo-pulse 1.5s infinite ease-in-out;
        }

        h1.acronym {
            position: relative;
            font-family: var(--font-mono);
            font-size: 2.2rem; /* Default smaller size for mobile-first approach */
            font-weight: 700;
            letter-spacing: 0.15em; /* Default smaller spacing */
            margin-bottom: 0.5rem;
            padding-left: 0.2em; /* Compensate for letter-spacing on last char */
            
            /* Animated Gradient */
            background: linear-gradient(90deg, var(--accent-secondary), var(--accent-primary), var(--accent-secondary));
            background-size: 200% auto;
            color: #000;
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: text-gradient-pan 4s linear infinite;
        }

        .subtitle { 
            font-size: 1rem; 
            color: var(--text-secondary); 
            max-width: 700px; 
            margin: 1rem auto 0 auto; 
            font-family: var(--font-mono); 
            letter-spacing: 1px;
            background: rgba(63, 131, 248, 0.1);
            padding: 0.5rem 1rem; border-radius: 2rem; border: 1px solid var(--border-color); display: inline-block;
        }        h1.acronym::before,
        h1.acronym::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--primary-bg);
            overflow: hidden;
            clip-path: inset(50% 50% 50% 50%);
        }
        h1.acronym::before {
            left: 2px;
            text-shadow: -1px 0 var(--danger);
            animation: glitch-1 2.5s infinite linear reverse;
        }
        h1.acronym::after {
            left: -2px;
            text-shadow: -1px 0 var(--accent-secondary);
            animation: glitch-2 2s infinite linear reverse;
        }

        .main-layout { display: grid; grid-template-columns: repeat(12, 1fr); gap: 2rem; }
        .tool-section { grid-column: 1 / -1; } /* Span all 12 columns by default */
        .sidebar-section { grid-column: 1 / -1; } /* Span all 12 columns by default */
        
        .tool-grid { 
            display: grid; 
            grid-template-columns: repeat(auto-fill, minmax(275px, 1fr)); 
            gap: 2rem; 
            align-items: stretch; 
            perspective: 1000px;
        }

        .tool-grid .tool-card .btn-group {
            margin-top: auto; /* This is the key change for alignment */
            padding-top: 1.5rem; /* Ensures space above the buttons */
        }

        @media (min-width: 768px) {
            /* Restore larger title on tablets and desktops */
            h1.acronym { font-size: 3rem; letter-spacing: 0.2em; }
        }

        @media (min-width: 1024px) {
            .container { padding: 2rem; }
            .tool-section { grid-column: span 8; }
            .sidebar-section { grid-column: span 4; }
        }

        @media (min-width: 1280px) {
            .tool-section { grid-column: span 9; }
            .sidebar-section {
                grid-column: span 3;
                position: sticky;
                top: 2rem;
                align-self: start; /* Prevents the grid item from stretching, which is needed for sticky to work */
                height: calc(100vh - 4rem); /* Set a height to enable internal scrolling */
                /* overflow-y is handled by the wrapper for sticky nav */
                display: flex;
                flex-direction: column;
            }
        }
        .tool-card {
            position: relative;
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 1rem;
            box-shadow: var(--shadow-md);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            transition: transform 0.5s ease, box-shadow 0.5s ease;
            display: flex;
            flex-direction: column;
            opacity: 0;
            overflow: hidden;
            transform-style: preserve-3d;
        }

        .tool-card::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 1rem;
            background: radial-gradient(circle 250px at var(--mouse-x, 50%) var(--mouse-y, 50%), rgba(255, 255, 255, 0.08), transparent 40%);
            opacity: 0;
            transition: opacity 0.4s;
            z-index: 1;
            pointer-events: none;
        }
        body.light-theme .tool-card::before { background: radial-gradient(circle 250px at var(--mouse-x, 50%) var(--mouse-y, 50%), rgba(0, 0, 0, 0.05), transparent 40%); }

        .tool-card.is-visible {
            animation: fadeIn 0.5s ease-out forwards;
            animation-delay: calc(var(--card-index) * 50ms);
        }

        /* Responsive hover effects */
        @media (hover: hover) and (min-width: 1024px) {
            .tool-card:hover { 
                transform: translateY(-5px); 
                box-shadow: var(--shadow-lg);
            }
            .tool-card:hover::before {
                opacity: 1;
            }
            .sidebar-section .tool-card:hover {
                transform: translateY(-2px);
                box-shadow: var(--shadow-md);
            }
            .sidebar-section .tool-card:hover::before {
                opacity: 1;
            }
        }
        .tool-card-content { padding: 1.5rem; flex-grow: 1; display: flex; flex-direction: column; position: relative; z-index: 2; }
        .tool-card h2 { font-size: 1.25rem; font-weight: 600; margin-bottom: 1.5rem; display: flex; align-items: center; gap: 0.75rem; padding-bottom: 1rem; border-bottom: 1px solid var(--border-color); }
        .tool-card h2 i { 
            color: var(--accent-primary); 
            transition: transform 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        @media (hover: hover) {
            .tool-card:hover h2 i {
                transform: rotate(360deg) scale(1.2);
            }
        }

        .card-loader {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(11, 16, 33, 0.8); backdrop-filter: blur(4px);
            display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 10;
        }
        .card-loader.active { display: flex; }
        .card-loader span { margin-top: 1rem; font-family: var(--font-mono); }

        .progress-bar {
            width: 80%;
            background-color: rgba(255, 255, 255, 0.1);
            height: 8px;
            border-radius: 4px;
            margin-top: 1rem;
            overflow: hidden;
        }
        .progress-bar-inner { width: 0%; height: 100%; background-color: var(--accent-primary); border-radius: 4px; transition: width 0.2s ease-out; }        
        .input-group { 
            margin-bottom: 1rem; 
            border: 2px dashed transparent; 
            border-radius: 0.75rem; 
            transition: all 0.2s ease; 
            padding: 0.5rem;
        }
        .input-group.drag-over {
            border-color: var(--accent-primary);
            background-color: rgba(63, 131, 248, 0.05);
        }
        .input-group:focus-within {
            border-color: var(--accent-primary);
            background-color: rgba(63, 131, 248, 0.05);
        }
        label { display: block; margin-bottom: 0.5rem; font-size: 0.875rem; font-weight: 500; color: var(--text-secondary); }
        input, select, textarea { width: 100%; padding: 0.75rem 1rem; background: var(--secondary-bg); border: 1px solid var(--border-color); border-radius: 0.5rem; color: var(--text-primary); font-size: 0.9rem; transition: border-color 0.2s, box-shadow 0.2s; font-family: var(--font-sans); }
        textarea { resize: vertical; min-height: 100px; font-family: var(--font-mono); }
        input:focus, select:focus, textarea:focus { outline: none; border-color: var(--accent-primary); box-shadow: 0 0 0 3px rgba(63, 131, 248, 0.15); }
        input:disabled, button:disabled { opacity: 0.5; cursor: not-allowed; }

        .btn-group { display: flex; flex-wrap: wrap; gap: 0.75rem; margin-top: 1.25rem; }
        button { background: var(--accent-primary); color: var(--text-primary); border: none; padding: 0.75rem 1.25rem; border-radius: 0.5rem; cursor: pointer; font-weight: 600; font-size: 0.9rem; transition: all 0.2s; display: flex; align-items: center; justify-content: center; gap: 0.5rem; }
        .btn-group button:not(.secondary) { flex: 1 1 auto; min-width: 120px; }
        .btn-group button.secondary { flex: 0 1 auto; }
        button:not(:disabled):hover { background: linear-gradient(45deg, #3F83F8, #2563EB); box-shadow: var(--shadow-lg); transform: translateY(-3px); }
        button:not(:disabled):active {
            transform: translateY(0px) scale(0.98);
            filter: brightness(0.9);
        }
        button.secondary { background: rgba(63, 131, 248, 0.1); color: var(--accent-primary); }
        button.secondary:not(:disabled):hover { background: rgba(63, 131, 248, 0.2); }
        button.danger-btn { background: var(--danger); color: white; }
        button.danger-btn:not(:disabled):hover { background: #c0392b; filter: brightness(1.1); }
        .loading-spinner { width: 1.5em; height: 1.5em; border: 3px solid currentColor; border-right-color: transparent; border-radius: 50%; animation: spin 0.6s linear infinite; }

        .output { background: var(--secondary-bg); border: 1px solid var(--border-color); border-radius: 0.5rem; padding: 1rem; margin-top: 1.5rem; min-height: 80px; font-family: var(--font-mono); white-space: pre-wrap; word-wrap: break-word; color: var(--text-secondary); font-size: 0.85rem; line-height: 1.8; flex-grow: 1; overflow-x: auto; }        .output:empty { display: none; }
        .output details { margin-top: 0.5rem; background: rgba(0,0,0,0.2); padding: 0.5rem; border-radius: 0.25rem; }
        .output summary { cursor: pointer; color: var(--accent-secondary); }
        .show-more-link { color: var(--accent-secondary); cursor: pointer; text-decoration: underline; font-style: italic; }
        .interpretation { font-style: italic; margin-top: 1rem; padding-top: 1rem; border-top: 1px dashed var(--border-color); color: var(--text-primary); font-size: 0.9rem; }
        .interpretation ul { padding-left: 1.5rem; margin-top: 0.5rem; }
        .interpretation li { margin-bottom: 0.5rem; }
        
        .hex-viewer { font-size: 0.8rem; line-height: 1.6; }
        .hex-viewer .row { display: flex; }
        .hex-viewer .hex-offset { color: var(--accent-secondary); width: 80px; flex-shrink: 0; }
        .hex-viewer .hex-byte { width: 2.5ch; text-align: center; }
        .hex-viewer .hex-ascii { letter-spacing: 2px; }
        #comparison-output, #password-output {
            white-space: normal;
            font-family: var(--font-sans);
        }
        .hex-viewer .diff { background-color: rgba(239, 68, 68, 0.3); color: var(--danger); border-radius: 2px; font-weight: bold; }
        .strength-bar-container {
            width: 100%;
            height: 8px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }
        .strength-bar {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s ease-in-out, background-color 0.3s ease-in-out;
        }
        .chat-container { display: flex; flex-direction: column; height: 100%; max-height: 400px; flex-grow: 1; }
        .chat-window { flex-grow: 1; overflow-y: auto; padding: 0.5rem; }
        .chat-message { margin-bottom: 0.75rem; padding: 0.65rem 1rem; border-radius: 1rem; max-width: 90%; line-height: 1.5; font-size: 0.9rem; }
        .user-message { background: var(--accent-primary); color: white; margin-left: auto; border-bottom-right-radius: 0.25rem; }
        .ai-message { background: var(--secondary-bg); color: var(--text-primary); margin-right: auto; border-bottom-left-radius: 0.25rem; }
        .ai-message ul { padding-left: 1.5rem; margin-top: 0.5rem; }
        
        .chat-input-area { display: flex; gap: 0.5rem; margin-top: 1rem; }
        .ai-quick-actions { display: flex; flex-wrap: wrap; gap: 0.5rem; margin: 0.75rem 0; }
        .ai-quick-actions button { padding: 0.25rem 0.75rem; font-size: 0.75rem; flex: 0; }

        .success { color: var(--success); } .warning { color: var(--warning); } .danger { color: var(--danger); } .info { color: var(--accent-secondary); }

        /* --- Interactive Chain of Custody Log --- */
        .coc-container {
            position: relative;
            padding-left: 25px; /* Space for the timeline line and dots */
            max-height: 400px;
            overflow-y: auto;
            padding-right: 5px;
        }
        .coc-container::-webkit-scrollbar { width: 4px; }
        .coc-container::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 2px; }
        .coc-container::before { /* The timeline vertical line */
            content: '';
            position: absolute;
            left: 10px;
            top: 15px;
            bottom: 15px;
            width: 2px;
            background-color: var(--border-color);
            border-radius: 1px;
        }
        .coc-entry {
            position: relative;
            padding: 0.5rem 0 0.5rem 0.5rem;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s;
            border-radius: 4px;
        }
        .coc-entry:hover { background-color: rgba(63, 131, 248, 0.1); }
        .coc-status { position: absolute; left: -21px; top: 50%; transform: translateY(-50%); width: 14px; height: 14px; border-radius: 50%; border: 3px solid var(--secondary-bg); }
        .status-high { background: var(--danger); } .status-medium { background: var(--warning); } .status-low { background: var(--success); }
        .coc-info .coc-action { font-weight: 500; color: var(--text-primary); font-size: 0.9rem; display: block; }
        .coc-info .coc-meta { font-size: 0.8rem; color: var(--text-secondary); display: block; margin-top: 2px; }
        .coc-info .coc-target { font-size: 0.8rem; color: var(--text-secondary); display: block; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        
        .timeline-container {
            position: relative;
            padding-left: 30px;
            border-left: 2px solid var(--border-color);
        }
        .timeline-item {
            position: relative;
            margin-bottom: 2rem;
        }
        .timeline-item:last-child {
            margin-bottom: 0;
        }
        .timeline-dot {
            position: absolute;
            left: -43px;
            top: 0;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            border: 3px solid var(--secondary-bg);
        }
        .timeline-dot.status-high { background-color: var(--danger); }
        .timeline-dot.status-medium { background-color: var(--warning); }
        .timeline-dot.status-low { background-color: var(--success); }

        .timeline-dot i { font-size: 0.8rem; }
        .timeline-content { background: rgba(63, 131, 248, 0.05); padding: 1rem; border-radius: 0.5rem; border: 1px solid var(--border-color); cursor: pointer; transition: background-color 0.2s, transform 0.2s; }
        .timeline-content:hover { background-color: rgba(63, 131, 248, 0.1); transform: translateX(5px); }
        .timeline-content h4 { margin: 0 0 0.25rem 0; font-size: 1.1rem; color: var(--text-primary); }
        .timeline-content .time { font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 0.5rem; }
        .timeline-content p { margin: 0; font-size: 0.9rem; }
        
        .navigator-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .navigator-list li {
            margin-bottom: 0.5rem;
        }
        .navigator-list li:last-child {
            margin-bottom: 0;
        }
        .navigator-list a {
            color: var(--text-secondary);
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.6rem 0.75rem;
            border-radius: 0.5rem;
            transition: background-color 0.2s, color 0.2s, transform 0.2s;
            font-weight: 500;
        }
        .navigator-list a:hover {
            background-color: rgba(63, 131, 248, 0.1);
            color: var(--text-primary);
            transform: translateX(5px);
        }
        .navigator-list a.active {
            background-color: rgba(63, 131, 248, 0.15);
            color: var(--text-primary);
            font-weight: 600;
            transform: translateX(5px);
        }
        .navigator-list a i {
            color: var(--accent-primary);
            width: 20px;
            text-align: center;
        }

        .tool-section.single-view .tool-grid {
            display: flex;
            justify-content: center;
            position: relative; /* Required for height animation */
            transition: height 0.3s ease-in-out;
        }
        .tool-section.single-view .tool-card {
            display: none; /* Hide all cards by default in single view */
            width: 100%;
            max-width: 750px; /* Prevent card from becoming too wide */
            flex-shrink: 0;
        }
        .tool-section.single-view .tool-card.active-tool {
            display: flex; /* Show only the active one */
            animation: fadeIn 0.4s ease-out forwards;
            transform: none !important; /* Override hover effects for a stable view */
        }
        .tool-section.single-view .tool-card.active-tool:hover {
            transform: none !important; /* Disable hover transform in single view */
            box-shadow: var(--shadow-md);
        }
        
        .modal-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0s 0.3s;
        }
        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
            transition: opacity 0.3s ease, visibility 0s 0s;
        }
        .modal-content { background: var(--secondary-bg); border-radius: 1rem; padding: 2rem; max-width: 800px; width: 90%; max-height: 80vh; overflow-y: auto; box-shadow: var(--shadow-lg); border: 1px solid var(--border-color); position: relative; transition: transform 0.3s ease-out, opacity 0.3s ease-out; transform: scale(0.95); opacity: 0; }
        .modal-overlay.active .modal-content { transform: scale(1); opacity: 1; }
        .modal-body { white-space: pre-wrap; font-family: var(--font-mono); word-wrap: break-word; }
        .modal-close { position: absolute; top: 1rem; right: 1rem; background: none; border: none; color: var(--text-secondary); font-size: 1.5rem; cursor: pointer; }
        
        .toggle-switch { display: flex; align-items: center; justify-content: space-between; margin-top: 1.5rem; }
        .toggle-switch label { margin-bottom: 0; }
        .switch { position: relative; display: inline-block; width: 50px; height: 28px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 28px; }
        .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--accent-primary); }
        input:checked + .slider:before { transform: translateX(22px); }
        
        .credits-card p { font-size: 0.9rem; color: var(--text-secondary); }
        .credits-card strong { color: var(--text-primary); font-weight: 500; }
 
        /* --- Styles for the Redesigned Network Analyzer --- */
        #network-output {
            background: var(--secondary-bg);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            padding: 1rem;
            margin-top: 1.5rem;
            min-height: 80px;
            font-family: var(--font-sans);
            line-height: 1.6;
            color: var(--text-secondary);
            flex-grow: 1;
            overflow-y: auto;
            overflow-x: hidden;
            white-space: normal; /* This is the key fix: ensure it's not pre-wrap */
        }
        #network-output:empty::before {
            content: 'Paste logs and click "Advanced Analysis".';
            font-style: italic;
        }
        .network-summary { display: flex; justify-content: space-around; text-align: center; background: rgba(0,0,0,0.1); padding: 0.75rem; border-radius: 0.5rem; margin-bottom: 1.5rem; }
        body.light-theme .network-summary { background: rgba(0,0,0,0.03); }
        .network-summary > div { display: flex; flex-direction: column; }
        .network-summary span:first-child { font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 0.25rem; }
        .threat-table { width: 100%; border-collapse: collapse; margin-top: 1.5rem; table-layout: fixed; }
        .threat-table th, .threat-table td { padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border-color); }
        .threat-table th { font-weight: 600; color: var(--text-secondary); font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px; }
        .threat-table td { vertical-align: top; font-size: 0.9rem; }
        .threat-table .threat-details-cell { font-family: var(--font-mono); font-size: 0.85rem; color: var(--text-secondary); word-break: break-word; }
        .threat-table strong { color: var(--text-primary); }
        .threat-table small { color: var(--text-secondary); font-size: 0.8rem; }
        .threat-table th:nth-child(1) { width: 15%; }
        .threat-table th:nth-child(2) { width: 25%; }
        .threat-table th:nth-child(3) { width: 60%; }
    </style>
    <style>
        /* --- NEW: Single View Mode & Navigators --- */
        .tool-navigator {
            background: var(--secondary-bg);
            border-radius: 1rem;
            padding: 0.5rem;
            margin-bottom: 2rem;
            border: 1px solid var(--border-color);
            animation: fadeIn 0.3s ease-out;
        }
        .tool-navigator .navigator-list {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 0.5rem;
            list-style: none;
        }
        .tool-navigator .navigator-list a {
            color: var(--text-secondary);
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.6rem 1rem;
            border-radius: 0.5rem;
            transition: all 0.2s;
            font-weight: 500;
        }
        .tool-navigator .navigator-list a:hover {
            background-color: rgba(63, 131, 248, 0.1);
            color: var(--text-primary);
        }
        .tool-navigator .navigator-list a.active {
            background-color: var(--accent-primary);
            color: var(--text-primary);
            font-weight: 600;
            box-shadow: var(--shadow-md);
        }
        .tool-navigator .navigator-list a:active {
            transform: scale(0.95);
            background-color: #2563EB;
        }

        #single-view-toggle-btn {
            flex-shrink: 0;
            padding: 0.5rem;
            width: 38px;
            height: 38px;
            border-radius: 50%;
            font-size: 0.9rem;
            line-height: 1;
            margin: 0;
        }
        #single-view-toggle-btn.active {
            background: var(--accent-primary);
            color: var(--text-primary);
        }
    </style>
    <style>
        /* --- NEW: Sidebar Interactivity Enhancements --- */
        @media (min-width: 1280px) {
            /* Sidebar layout is now defined in the main responsive block for clarity */
            .sidebar-content-wrapper {
                overflow-y: auto;
                flex-grow: 1;
                padding-right: 10px; /* space for scrollbar */
                margin-right: -10px; /* hide the space if no scrollbar */
                scroll-padding-top: 1rem; /* Prevent content from hiding under sticky nav */
            }
            /* Custom scrollbar for sidebar */
            .sidebar-content-wrapper::-webkit-scrollbar { width: 6px; }
            .sidebar-content-wrapper::-webkit-scrollbar-track { background: transparent; }
            .sidebar-content-wrapper::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 3px; }
            .sidebar-content-wrapper::-webkit-scrollbar-thumb:hover { background: var(--accent-primary); }
        }

        .sidebar-navigator {
            position: sticky;
            top: 0;
            display: flex;
            align-items: center;
            background: var(--primary-bg);
            z-index: 5;
            padding: 0.5rem 0;
            margin-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        .sidebar-navigator .navigator-list {
            display: flex;
            flex-grow: 1;
            justify-content: space-between;
            gap: 0.5rem;
        }
        .sidebar-navigator .navigator-list a {
            flex-direction: column;
            gap: 0.25rem;
            padding: 0.5rem;
            font-size: 0.8rem;
            text-align: center;
        }
        .sidebar-navigator .navigator-list a:hover {
            transform: translateY(-2px);
        }
        .sidebar-navigator .navigator-list a.active {
            color: var(--accent-primary);
            transform: translateY(-2px);
            background-color: rgba(63, 131, 248, 0.1);
        }
        .sidebar-navigator .navigator-list a i { font-size: 1.2rem; margin-bottom: 0.25rem; }
    </style>
    <style>
        /* --- NEW: UI/UX Polish --- */
        #metadata-output {
            white-space: normal;
            font-family: var(--font-sans);
            line-height: 1.6;
            padding: 0;
            background: transparent;
            border: none;
        }
        .key-findings-box {
            background: rgba(63, 131, 248, 0.05);
            border: 1px solid var(--border-color);
            border-radius: 0.75rem;
            padding: 1rem;
            margin-bottom: 1.5rem;
        }
        body.light-theme .key-findings-box { background: #F3F4F6; }
        .key-findings-box h3 {
            margin: 0 0 1rem 0;
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
        }
        .key-finding-item {
            display: grid;
            grid-template-columns: 120px 1fr;
            gap: 1rem;
            padding: 0.5rem 0;
            font-size: 0.9rem;
            border-bottom: 1px solid rgba(63, 131, 248, 0.1);
        }
        body.light-theme .key-finding-item { border-bottom-color: #E5E7EB; }
        .key-finding-item:last-child { border-bottom: none; }
        .key-finding-item .key {
            font-weight: 500;
            color: var(--text-secondary);
        }
        .key-finding-item .value {
            color: var(--text-primary);
            word-break: break-all;
        }
        body.no-animations #background-canvas {
            display: none !important;
        }

        /* --- NEW: Accessibility Improvement for Animations --- */
        body.no-animations h1.acronym::before,
        body.no-animations h1.acronym::after {
            display: none;
        }
    </style>
    <style>
        /* --- NEW: Professional UI Polish & Readability --- */
        #password-output:not(:empty) {
            padding: 0;
            background: transparent;
            border: none;
        }
        .password-audit-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            text-align: center;
        }
        .audit-metric {
            background: var(--secondary-bg);
            padding: 1rem;
            border-radius: 0.75rem;
            border: 1px solid var(--border-color);
        }
        .audit-metric .label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
            display: block;
        }
        .audit-metric .value {
            font-size: 1.2rem;
            font-weight: 600;
            font-family: var(--font-mono);
        }
        .password-recommendations {
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-color);
        }
        .password-recommendations h4 { font-size: 1rem; margin-bottom: 0.75rem; }
        .password-recommendations ul { list-style: none; padding: 0; }
        .password-recommendations li { background: rgba(245, 158, 11, 0.1); padding: 0.5rem 1rem; border-radius: 0.5rem; margin-bottom: 0.5rem; display: flex; align-items: center; gap: 0.75rem; font-size: 0.9rem; }
        .password-recommendations li::before { content: '\f071'; font-family: 'Font Awesome 6 Free'; font-weight: 900; color: var(--warning); }
        .password-recommendations li.good-practice { background: rgba(16, 185, 129, 0.1); }
        .password-recommendations li.good-practice::before { content: '\f058'; color: var(--success); }

        #comparison-output:not(:empty) {
            padding: 0;
            background: transparent;
            border: none;
        }
        .comparison-summary {
            padding: 1rem; border-radius: 0.75rem; margin-bottom: 1.5rem; font-size: 1.1rem; font-weight: 600; text-align: center;
        }
        .summary-identical { background: rgba(16, 185, 129, 0.1); color: var(--success); border: 1px solid var(--success); }
        .summary-different { background: rgba(239, 68, 68, 0.1); color: var(--danger); border: 1px solid var(--danger); }
        .comparison-results-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            table-layout: fixed;
        }
        .comparison-results-table th, .comparison-results-table td {
            padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--border-color); vertical-align: middle;
        }
        .comparison-results-table th {
            font-weight: 500; color: var(--text-secondary); width: 80px;
        }
        .comparison-results-table td {
            font-family: var(--font-mono); font-size: 0.85rem; word-break: break-all;
        }
        .comparison-results-table .file-header {
            font-family: var(--font-sans); font-weight: 600; font-size: 0.9rem; color: var(--text-primary); padding-bottom: 1rem;
        }
        #comparison-output .interpretation {
            margin-top: 1rem; padding: 1rem; border-radius: 0.5rem; background: var(--secondary-bg); border: 1px solid var(--border-color);
        }
        </style>
    <style>
        /* --- NEW: Toast Notifications --- */
        #toast-container {
            position: fixed;
            top: 1.5rem;
            right: 1.5rem;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        .toast {
            background: var(--secondary-bg);
            color: var(--text-primary);
            padding: 1rem 1.5rem;
            border-radius: 0.5rem;
            box-shadow: var(--shadow-lg);
            border: 1px solid var(--border-color);
            border-left: 5px solid var(--accent-primary);
            display: flex;
            align-items: center;
            gap: 1rem;
            min-width: 300px;
            opacity: 0;
            transform: translateX(100%);
            animation: slideInToast 0.5s forwards, fadeOutToast 0.5s 4.5s forwards;
        }
        .toast.toast-success { border-left-color: var(--success); }
        .toast.toast-danger { border-left-color: var(--danger); }
        .toast i { font-size: 1.2rem; }
        .toast.toast-success i { color: var(--success); }
        .toast.toast-danger i { color: var(--danger); }

        @keyframes slideInToast { to { opacity: 1; transform: translateX(0); } }
        @keyframes fadeOutToast { from { opacity: 1; transform: translateX(0); } to { opacity: 0; transform: translateX(100%); } }
    </style>
    <style>
        /* --- NEW: Forensic Guide --- */
        #help-guide-btn {
            position: fixed;
            top: 1.25rem;
            left: 1.25rem;
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background: var(--accent-primary);
            color: white;
            border: 2px solid var(--primary-bg);
            box-shadow: var(--shadow-lg);
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1001;
            transition: all 0.3s ease;
        }
        #help-guide-btn:hover {
            transform: scale(1.1) rotate(15deg);
            background: var(--accent-secondary);
        }
        .guide-container { display: flex; flex-direction: column; margin-top: 1.5rem; }
        .guide-tabs { display: flex; flex-wrap: wrap; gap: 0.5rem; border-bottom: 2px solid var(--border-color); padding-bottom: 0.75rem; margin-bottom: 1.5rem; }
        .guide-tab-btn { padding: 0.75rem 1.25rem; font-size: 0.9rem; font-weight: 600; background: transparent; color: var(--text-secondary); border: none; border-bottom: 3px solid transparent; cursor: pointer; transition: all 0.2s ease; margin-bottom: -2px; }
        .guide-tab-btn:hover { background: rgba(63, 131, 248, 0.1); color: var(--text-primary); }
        .guide-tab-btn.active { color: var(--accent-primary); border-bottom-color: var(--accent-primary); }
        .guide-tab-content { display: none; animation: fadeIn 0.4s ease-out; }
        .guide-tab-content.active { display: block; }
        .guide-tab-content h4 { font-size: 1.2rem; color: var(--accent-primary); margin-top: 1rem; margin-bottom: 0.5rem; }
        .guide-tab-content p { color: var(--text-secondary); line-height: 1.7; margin-bottom: 1rem; }
        .guide-tab-content ul { list-style: none; padding-left: 0; }
        .guide-tab-content > ul > li { position: relative; padding-left: 25px; margin-bottom: 1rem; }
        .guide-tab-content > ul > li::before { content: '\f105'; font-family: 'Font Awesome 6 Free'; font-weight: 900; position: absolute; left: 0; top: 4px; color: var(--accent-secondary); }
        .guide-tab-content ul ul { list-style: none; padding-left: 20px; margin-top: 0.5rem; }
        .guide-tab-content ul ul li { position: relative; padding-left: 20px; margin-bottom: 0.5rem; }
        .guide-tab-content ul ul li::before { content: '\2023'; position: absolute; left: 0; top: 0; color: var(--text-secondary); }

        /* --- NEW: Animation for Guide's "Highlight" feature --- */
        @keyframes highlight-pulse {
            0% { box-shadow: 0 0 0 0 rgba(63, 131, 248, 0.7); transform: scale(1); }
            70% { box-shadow: 0 0 0 20px rgba(63, 131, 248, 0); transform: scale(1.02); }
            100% { box-shadow: 0 0 0 0 rgba(63, 131, 248, 0); transform: scale(1); }
        }
        .tool-card.highlight-pulse {
            animation: highlight-pulse 1.5s ease-out;
        }
    </style>
    <style>
        /* --- NEW: Mobile Responsiveness & Fit --- */
        @media (max-width: 480px) {
            .container {
                padding: 0.75rem;
            }
            header {
                margin-bottom: 2rem;
                padding-bottom: 1.5rem;
            }
            h1.acronym {
                font-size: 1.8rem;
                letter-spacing: 0.1em;
            }
            .subtitle {
                font-size: 0.8rem;
                padding: 0.4rem 0.8rem;
                line-height: 1.5;
                max-width: 95%;
            }
            .tool-grid {
                gap: 1rem;
            }
            .main-layout {
                gap: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <canvas id="background-canvas"></canvas>
    <button id="help-guide-btn" title="Open Forensic Guide"><i class="fas fa-question-circle"></i></button>
    <div class="container">
        <header>
            <a href="" class="logo-link" aria-label="NITTALA Forensic Suite Home">
                <svg id="logo-n" width="95" height="95" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <g class="logo-n-glow">
                        <path class="logo-n-path" d="M 20 80 L 20 20" stroke-width="12" stroke-linecap="round" stroke-linejoin="round"/>
                        <path class="logo-n-path" d="M 20 20 L 80 80" stroke-width="12" stroke-linecap="round" stroke-linejoin="round"/>
                        <path class="logo-n-path" d="M 80 20 L 80 80" stroke-width="12" stroke-linecap="round" stroke-linejoin="round"/>
                    </g>
                </svg>
            </a>
            <h1 class="acronym" data-text="N.I.T.T.A.L.A">N.I.T.T.A.L.A</h1>
            <p class="subtitle">Node-based Investigative Toolkit for Trace Analysis and Log Auditing</p>
        </header>

        <main class="main-layout">
            <section class="tool-section">
                <div class="tool-navigator" style="display: none;">
                    <ul class="navigator-list">
                        <li><a href="#integrity-card" class="active"><i class="fas fa-shield-virus"></i> Integrity</a></li>
                        <li><a href="#comparison-card"><i class="fas fa-exchange-alt"></i> Compare</a></li>
                        <li><a href="#metadata-card"><i class="fas fa-camera-retro"></i> Metadata</a></li>
                        <li><a href="#stego-card"><i class="fas fa-eye-slash"></i> Steganography</a></li>
                        <li><a href="#password-card"><i class="fas fa-key"></i> Password</a></li>
                        <li><a href="#network-card"><i class="fas fa-network-wired"></i> Network</a></li>
                    </ul>
                </div>
                <div class="tool-grid">
                    <!-- File Integrity & Threat Scanner Card -->
                    <div id="integrity-card" class="tool-card" style="--card-index: 2;">
                        <div class="card-loader">
                            <div class="loading-spinner"></div>
                            <span>Processing...</span>
                            <div class="progress-bar"><div class="progress-bar-inner"></div></div>
                        </div>
                        <div class="tool-card-content">
                            <h2><i class="fas fa-shield-virus" aria-hidden="true"></i> File Integrity Scanner</h2>
                            <div class="input-group">
                                <label for="file-upload">Select File for Analysis</label>
                                <input type="file" id="file-upload">
                            </div>
                            <div class="btn-group">
                                <button onclick="runAnalysis('integrity-card', generateHash)"><i class="fas fa-broadcast-tower"></i> Full Scan</button>
                                <button id="find-carve-btn" class="secondary" onclick="runAnalysis('integrity-card', findAndCarveSignatures)" disabled><i class="fas fa-magic"></i> Find & Carve</button>
                                <button class="secondary" onclick="clearToolState('integrity-card')"><i class="fas fa-times-circle"></i> Clear</button>
                            </div>
                            <div id="hash-output" class="output">Select a file and click "Full Scan".</div>
                            <div id="carve-output" class="output" style="margin-top: 1rem; display: none;"></div>
                            <div id="hex-viewer-output" class="output hex-viewer" style="margin-top: 1rem; display: none; max-height: 300px; overflow-y: auto;"></div>
                            <canvas id="entropy-chart" height="100" style="margin-top: 1rem; display: none;"></canvas>
                            <canvas id="byte-plot-chart" height="100" style="margin-top: 1rem; display: none;"></canvas>
                                </div>
                            </div>
                    
                    <!-- File Comparison Tool -->
                    <div id="comparison-card" class="tool-card" style="--card-index: 3;">
                        <div class="card-loader">
                            <div class="loading-spinner"></div>
                            <span>Comparing...</span>
                            <div class="progress-bar"><div class="progress-bar-inner"></div></div>
                        </div>
                        <div class="tool-card-content">
                            <h2><i class="fas fa-exchange-alt" aria-hidden="true"></i> File Comparison Tool</h2>
                            <div class="input-group">
                                <label for="file-compare-1">Original File</label>
                                <input type="file" id="file-compare-1">
                            </div>
                            <div class="input-group">
                                <label for="file-compare-2">Comparison File</label>
                                <input type="file" id="file-compare-2">
                            </div>
                            <div class="btn-group">
                                <button onclick="runAnalysis('comparison-card', compareFiles)"><i class="fas fa-equals"></i> Compare Files</button>
                                <button class="secondary" onclick="clearToolState('comparison-card')"><i class="fas fa-times-circle"></i> Clear</button>
                            </div>
                            <div id="comparison-output" class="output">Select two files and click "Compare Files".</div>
                            <canvas id="diff-map-canvas" height="50" style="margin-top: 1rem; display: none; border: 1px solid var(--border-color); border-radius: 0.5rem;"></canvas>
                        </div>
                    </div>
                    
                    <!-- Metadata Analyzer Card -->
                    <div id="metadata-card" class="tool-card" style="--card-index: 3;">
                        <div class="card-loader"><div class="loading-spinner"></div><span>Analyzing...</span></div>
                        <div class="tool-card-content">
                            <h2><i class="fas fa-camera-retro"></i> Metadata Analyzer</h2>
                            <div class="input-group">
                                <label for="photo-upload">Select Image/File</label>
                                <input type="file" id="photo-upload" accept="image/*,video/*,.pdf,.doc,.docx">
                            </div>
                            <div class="btn-group">
                                <button onclick="runAnalysis('metadata-card', analyzeMetadata)"><i class="fas fa-search-dollar"></i> Analyze Metadata</button>
                                <button id="meta-ai-btn" class="secondary" onclick="getMetadataAIInsights()" style="display: none;">✨ Get AI Insights</button>
                                <button class="secondary" onclick="clearToolState('metadata-card')"><i class="fas fa-times-circle"></i> Clear</button>
                            </div>
                            <div id="metadata-output" class="output">Select a file and click "Analyze Metadata".</div>
                            <div id="map-container" style="height: 200px; margin-top: 1rem; border-radius: 0.5rem; display: none; z-index: 1;"></div>
                        </div>
                    </div>

                    <!-- Steganography Analyzer Card -->
                    <div id="stego-card" class="tool-card" style="--card-index: 4;">
                        <div class="card-loader"><div class="loading-spinner"></div><span>Scanning...</span></div>
                        <div class="tool-card-content">
                            <h2><i class="fas fa-eye-slash"></i> Steganography Analyzer</h2>
                             <div class="input-group">
                                <label for="steg-file">Upload Image (PNG recommended)</label>
                                <input type="file" id="steg-file" accept="image/png, image/bmp, image/jpeg">
                            </div>
                            <div style="display: flex; gap: 1rem; margin-bottom: 1rem;">
                                <div class="input-group" style="flex: 1;">
                                    <label for="steg-channel">Channel</label>
                                    <select id="steg-channel">
                                        <option value="0">Red</option>
                                        <option value="1">Green</option>
                                        <option value="2">Blue</option>
                                        <option value="3" selected>Alpha</option>
                                    </select>
                                </div>
                                <div class="input-group" style="flex: 1;">
                                    <label for="steg-bit-plane">Bit Plane</label>
                                    <select id="steg-bit-plane">
                                        <option value="0">LSB (0)</option> <option value="1">1</option> <option value="2">2</option> <option value="3">3</option>
                                        <option value="4">4</option> <option value="5">5</option> <option value="6">6</option> <option value="7">MSB (7)</option>
                                    </select>
                                </div>
                            </div>
                            <div class="btn-group">
                                <button onclick="runAnalysis('stego-card', analyzeSteganography)"><i class="fas fa-search-plus"></i> Analyze Bit Plane</button>
                                <button class="secondary" onclick="clearToolState('stego-card')"><i class="fas fa-times-circle"></i> Clear</button>
                            </div>
                            <div id="steg-output" class="output">Select an image and click "Analyze Bit Plane".</div>
                            <canvas id="steg-preview-canvas" style="margin-top: 1rem; display: none; max-width: 100%; border: 1px solid var(--border-color); border-radius: 0.5rem;"></canvas>
                        </div>
                    </div>

                    <!-- Password Strength Card -->
                     <div id="password-card" class="tool-card" style="--card-index: 5;">
                        <div class="card-loader"><div class="loading-spinner"></div><span>Analyzing...</span></div>
                        <div class="tool-card-content">
                            <h2><i class="fas fa-key"></i> Password Audit</h2>
                            <div class="input-group">
                                <label for="password-input">Enter Password</label>
                                <input type="password" id="password-input" placeholder="Enter password for full analysis..." oninput="updatePasswordStrengthBarVisuals()">
                            </div>
                            <button onclick="runAnalysis('password-card', analyzePassword)" style="width: 100%; margin-bottom: 1.5rem;"><i class="fas fa-bolt"></i> Full Analysis</button>
                            <div id="password-strength-visual" style="margin-bottom: 1rem;">
                                <div class="strength-bar-container">
                                    <div id="strength-bar-main" class="strength-bar"></div>
                                </div>
                                <div id="strength-text" style="font-size: 0.8rem; text-align: right; margin-top: 0.25rem; color: var(--text-secondary);"></div>
                            </div>
                            <div id="password-output" class="output" style="min-height: 0;">Enter a password and click "Full Analysis".</div>
                            <div class="btn-group">
                                <button class="secondary" onclick="clearToolState('password-card')"><i class="fas fa-times-circle"></i> Clear</button>
                            </div>
                        </div>
                    </div>

                    <!-- Network Log Analyzer Card -->
                    <div id="network-card" class="tool-card" style="--card-index: 6;">
                        <div class="card-loader"><div class="loading-spinner"></div><span>Analyzing...</span></div>
                        <div class="tool-card-content">
                            <h2><i class="fas fa-network-wired"></i> Advanced Network Log Analyzer</h2>
                            <div class="input-group">
                                <label for="network-input">Paste System or Network Logs</label>
                                <textarea id="network-input" placeholder="Paste logs (e.g., auth.log, firewall, web server) here..."></textarea>
                            </div>
                            <div class="input-group">
                                <label for="ip-watchlist">IP Watchlist (comma or newline separated)</label>
                                <textarea id="ip-watchlist" placeholder="e.g., 192.168.1.100, 8.8.8.8, ..." style="min-height: 60px;"></textarea>
                            </div>
                            <div class="btn-group">
                                <button onclick="runAnalysis('network-card', analyzeNetworkAdvanced)"><i class="fas fa-wave-square"></i> Advanced Analysis</button>
                                <button id="net-ai-btn" class="secondary" onclick="getNetworkAIInsights()" style="display: none;">✨ Explain Threats with AI</button>
                                <button class="secondary" onclick="clearToolState('network-card')"><i class="fas fa-times-circle"></i> Clear</button>
                            </div>
                            <div id="network-output"></div>
                        </div>
                    </div>
                </div>
            </section>
            
            <aside class="sidebar-section">
                <div class="sidebar-navigator" style="gap: 1rem;">
                    <ul class="navigator-list">
                        <li><a href="#case-notes-card" class="active"><i class="fas fa-pencil-alt"></i> Notes</a></li>
                        <li><a href="#report-gen-card"><i class="fas fa-file-invoice"></i> Report</a></li>
                        <li><a href="#coc-card"><i class="fas fa-book"></i> CoC Log</a></li>
                        <li><a href="#settings-card"><i class="fas fa-cog"></i> Settings</a></li>
                        <li><a href="#credits-card"><i class="fas fa-user-graduate"></i> Credits</a></li>
                    </ul>
                    <button id="single-view-toggle-btn" class="secondary" title="Toggle Single Tool View">
                        <i class="fas fa-columns"></i>
                    </button>
                </div>
                <div class="sidebar-content-wrapper">
                    <!-- Case Notes Card -->
                    <div id="case-notes-card" class="tool-card" style="--card-index: 9;">
                        <div class="tool-card-content">
                            <h2><i class="fas fa-pencil-alt"></i> Case Notes</h2>
                            <div class="input-group" style="padding: 0; border: none; margin-bottom: 0; flex-grow: 1; display: flex; flex-direction: column;">
                                <label for="case-notes-textarea">Investigator's Notes (auto-saved with case)</label>
                                <textarea id="case-notes-textarea" placeholder="Enter observations, findings, and next steps here..." style="flex-grow: 1; min-height: 250px;"></textarea>
                            </div>
                        </div>
                    </div>
                    <!-- Report Generation Card -->
                    <div id="report-gen-card" class="tool-card" style="margin-top: 2rem; --card-index: 10;">
                        <div class="tool-card-content">
                            <h2><i class="fas fa-file-invoice"></i> Report Generation</h2>
                            <div class="input-group">
                                <label for="case-name">Case Name / ID</label>
                                <input type="text" id="case-name" placeholder="e.g., Case-2025-001">
                            </div>
                             <div class="input-group">
                                <label for="investigator-name">Investigator Name</label>
                                <input type="text" id="investigator-name" placeholder="John Doe">
                            </div>
                            <div class="input-group">
                                <label for="org-name">Organization Name</label>
                                <input type="text" id="org-name" placeholder="e.g., Forensic Unit">
                            </div>
                            <div class="input-group">
                                <label for="case-type">Case Type</label>
                                <input type="text" id="case-type" placeholder="e.g., Data Breach Investigation">
                            </div>
                            <div class="toggle-switch">
                                <label for="court-mode">Courtroom-Ready Mode</label>
                                <label class="switch">
                                    <input type="checkbox" id="court-mode">
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div class="btn-group">
                                <button onclick="exportToPDF()"><i class="fas fa-file-pdf"></i> Export PDF</button>
                            </div>
                        </div>
                    </div>
                    <!-- Chain of Custody Card -->
                    <div id="coc-card" class="tool-card" style="margin-top: 2rem; --card-index: 11;">
                        <div class="tool-card-content">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; flex-wrap: wrap; gap: 0.5rem;">
                                <h2 style="margin-bottom: 0;"><i class="fas fa-book"></i> Chain of Custody Log</h2>
                                <div class="btn-group" style="flex: 0; margin-top: 0; gap: 0.5rem;">
                                    <button id="add-coc-entry-btn" class="secondary" style="padding: 0.4rem 0.8rem; font-size: 0.8rem;"><i class="fas fa-plus"></i> Add</button>
                                    <button id="timeline-view-btn" class="secondary" style="padding: 0.4rem 0.8rem; font-size: 0.8rem;"><i class="fas fa-stream"></i> View</button>
                                </div>
                            </div>
                            <div id="coc-log" class="coc-container"></div>
                            <p style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 1rem; font-style: italic;">
                                This log is cryptographically secured. All entries are reflected in the final PDF report to ensure a tamper-evident record.
                            </p>
                        </div>
                    </div>
                    <!-- Settings Card -->
                    <div id="settings-card" class="tool-card" style="margin-top: 2rem; --card-index: 12;">
                        <div class="tool-card-content">
                            <h2><i class="fas fa-cog"></i> Settings</h2>
                            <div class="toggle-switch">
                                <label for="theme-toggle">Light Theme</label>
                                <label class="switch">
                                    <input type="checkbox" id="theme-toggle">
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div class="toggle-switch" style="margin-top: 1rem;">
                                <label for="animation-toggle" title="Completely disables the background constellation and cursor trail for maximum performance.">Disable Background Animation</label>
                                <label class="switch">
                                    <input type="checkbox" id="animation-toggle">
                                    <span class="slider"></span>
                                </label>
                            </div>
                            <div class="input-group" style="padding: 0; border: none; margin-top: 1rem;">
                                <label for="setting-investigator-name">Default Investigator Name</label>
                                <input type="text" id="setting-investigator-name" placeholder="e.g., John Doe">
                            </div>
                            <div class="input-group" style="padding: 0; border: none; margin-top: 1rem;">
                                <label for="setting-org-name">Default Organization Name</label>
                                <input type="text" id="setting-org-name" placeholder="Saved to this browser...">
                            </div>
                            <div class="btn-group" style="margin-top: 0.75rem;">
                                <button class="danger-btn" onclick="clearAllSettings()"><i class="fas fa-trash-alt"></i> Clear Saved Settings</button>
                            </div>
                        </div>
                    </div>
                    <!-- Credits Card -->
                    <div id="credits-card" class="tool-card credits-card" style="margin-top: 2rem; --card-index: 13;">
                        <div class="tool-card-content">
                            <h2><i class="fas fa-user-graduate"></i> Credits</h2>
                            <p><strong>Developed By:</strong> PHANEENDHAR.NITTALA</p>
                            <p><strong>Education:</strong> B.Sc. Forensic Science</p>
                            <p><strong>University:</strong> Centurion University of Technology and Management (Andhra Pradesh)</p>
                        </div>
                    </div>
                </div>
            </aside>
        </main>
    </div>
    
    <div class="modal-overlay" id="coc-modal">
        <div class="modal-content">
            <button class="modal-close" onclick="closeModal()">×</button>
            <h3 class="modal-title" id="modal-title"></h3>
            <div class="modal-body" id="modal-body"></div>
            <div class="btn-group" style="margin-top: 1.5rem;">
                <button id="copy-coc-btn" class="secondary"><i class="fas fa-copy"></i> Copy to Clipboard</button>
                <button id="verify-coc-btn" class="secondary"><i class="fas fa-check-double"></i> Verify Chain Integrity</button>
            </div>
        </div>
    </div>

    <!-- Timeline Modal -->
    <div class="modal-overlay" id="timeline-modal">
        <div class="modal-content" style="max-width: 1000px;">
            <button class="modal-close" onclick="closeTimelineModal()">×</button>
            <h3 class="modal-title">Chain of Custody Timeline</h3>
            <div class="modal-body" id="timeline-body">
                <!-- Timeline will be generated here -->
            </div>
        </div>
    </div>
    
    <!-- Manual CoC Entry Modal -->
    <div class="modal-overlay" id="add-coc-modal">
        <div class="modal-content" style="max-width: 600px;">
            <button class="modal-close" onclick="closeAddCocModal()">×</button>
            <h3 class="modal-title">Add Manual Chain of Custody Entry</h3>
            <div class="modal-body" id="add-coc-body">
                <div class="input-group" style="padding:0; border:none;">
                    <label for="coc-manual-action">Action</label>
                    <input type="text" id="coc-manual-action" placeholder="e.g., Physical evidence acquired">
                </div>
                <div class="input-group" style="padding:0; border:none;">
                    <label for="coc-manual-target">Target</label>
                    <input type="text" id="coc-manual-target" placeholder="e.g., USB Drive SN #12345">
                </div>
                <div class="input-group" style="padding:0; border:none;">
                    <label for="coc-manual-details">Details (Optional)</label>
                    <textarea id="coc-manual-details" placeholder="Any relevant details..." style="min-height: 80px;"></textarea>
                </div>
                <div class="input-group" style="padding:0; border:none;"><label for="coc-manual-status">Status / Risk Level</label><select id="coc-manual-status"><option value="low">Low</option><option value="medium" selected>Medium</option><option value="high">High</option></select></div>
                <div class="btn-group" style="margin-top: 1.5rem;"><button onclick="submitManualCoCEntry()">Add Entry</button></div>
            </div>
        </div>
    </div>

    <!-- Forensic Guide Modal -->
    <div class="modal-overlay" id="guide-modal">
        <div class="modal-content" style="max-width: 900px; width: 95%;">
            <button class="modal-close" onclick="document.getElementById('guide-modal').classList.remove('active')">×</button>
            <h3 class="modal-title">N.I.T.T.A.L.A. Forensic Guide</h3>
            <div class="guide-container">
                <div class="guide-tabs">
                    <button class="guide-tab-btn active" data-tab="integrity"><i class="fas fa-shield-virus"></i> Integrity Scanner</button>
                    <button class="guide-tab-btn" data-tab="comparison"><i class="fas fa-exchange-alt"></i> Comparison Tool</button>
                    <button class="guide-tab-btn" data-tab="metadata"><i class="fas fa-camera-retro"></i> Metadata Analyzer</button>
                    <button class="guide-tab-btn" data-tab="stego"><i class="fas fa-eye-slash"></i> Steganography</button>
                    <button class="guide-tab-btn" data-tab="password"><i class="fas fa-key"></i> Password Audit</button>
                    <button class="guide-tab-btn" data-tab="network"><i class="fas fa-network-wired"></i> Network Logs</button>
                </div>
                <div class="guide-content">
                    <!-- Integrity Scanner Content -->
                    <div class="guide-tab-content active" id="guide-integrity">
                        <div class="guide-header">
                            <h4><i class="fas fa-shield-virus"></i> Integrity Scanner</h4>
                            <button class="secondary" onclick="highlightToolCard('integrity-card')"><i class="fas fa-crosshairs"></i> Highlight on Page</button>
                        </div>
                        <h5>What It Does</h5>
                        <p>Calculates unique digital fingerprints (hashes) for any file and checks it for known threats and anomalies like hidden data.</p>
                        <h5>How to Interpret the Results</h5>
                        <ul>
                            <li><strong>Cryptographic Hashes (MD5, SHA-1, SHA-256):</strong> These are unique IDs for the file's content. If even one bit of the file changes, these hashes will change completely. This is the core of verifying file integrity. SHA-256 is the current industry standard.</li>
                            <li><strong>Threat Intelligence Analysis:</strong> The file's SHA-256 hash is checked against an internal database of known malware signatures. A "match" is a definitive indicator that the file is a known threat.</li>
                            <li><strong>Entropy Analysis:</strong> Entropy measures randomness on a scale of 0 (total order) to 8.0 (total randomness).
                                <ul>
                                    <li><strong>High Entropy (&gt; 7.5):</strong> Common for compressed files (ZIP, JPG) or encrypted data. If the file type is not typically compressed (like a TXT or EXE), high entropy is a strong indicator of encryption or packing, which can be used to hide malware.</li>
                                    <li><strong>Low Entropy (&lt; 6.0):</strong> Common for uncompressed text or files with lots of repeating data.</li>
                                </ul>
                            </li>
                             <li><strong>File Carving:</strong> This feature scans the entire file for the "magic numbers" (headers) of other file types. This can uncover files that have been hidden inside another file (e.g., a JPG image appended to the end of a DOCX document).</li>
                        </ul>
                    </div>
                    <!-- Comparison Tool Content -->
                    <div class="guide-tab-content" id="guide-comparison">
                        <div class="guide-header">
                            <h4><i class="fas fa-exchange-alt"></i> Comparison Tool</h4>
                            <button class="secondary" onclick="highlightToolCard('comparison-card')"><i class="fas fa-crosshairs"></i> Highlight on Page</button>
                        </div>
                        <h5>What It Does</h5>
                        <p>Performs a deep, byte-by-byte comparison of two files to determine if they are different, and if so, where the differences lie.</p>
                        <h5>How to Interpret the Results</h5>
                        <ul>
                            <li><strong>Identical / Different Status:</strong> This is based on a cryptographic hash comparison. If the SHA-256 hashes match, the files are 100% identical.</li>
                            <li><strong>Diff Map:</strong> This is a powerful visual tool. It represents the entire file as a grid. Each block in the grid corresponds to a section of the file.
                                <ul>
                                    <li><span style="color: var(--diff-color);">■</span> Red blocks indicate that the data in that section is <strong>different</strong> between the two files.</li>
                                    <li><span style="color: var(--border-color);">■</span> Faint blocks indicate the data is <strong>identical</strong> in that section.</li>
                                </ul>
                                This map allows you to see at a glance how much of a file has changed and in what location (e.g., changes only at the beginning, end, or scattered throughout).
                            </li>
                        </ul>
                    </div>
                    <!-- Metadata Analyzer Content -->
                    <div class="guide-tab-content" id="guide-metadata">
                        <div class="guide-header">
                            <h4><i class="fas fa-camera-retro"></i> Metadata Analyzer</h4>
                            <button class="secondary" onclick="highlightToolCard('metadata-card')"><i class="fas fa-crosshairs"></i> Highlight on Page</button>
                        </div>
                        <h5>What It Does</h5>
                        <p>Extracts hidden information (metadata) embedded within files, particularly images, videos, and documents.</p>
                        <h5>How to Interpret the Results</h5>
                        <ul>
                            <li><strong>Key Forensic Findings:</strong> This box highlights the most forensically relevant data points for quick assessment.</li>
                            <li><strong>GPS Coordinates:</strong> If present, this is a critical finding, showing the precise latitude and longitude where a photo or video was taken. The tool displays this on an interactive map.</li>
                            <li><strong>Timestamp (DateTimeOriginal):</strong> This is often the exact date and time a photo was captured, which can be crucial for building a timeline of events.</li>
                            <li><strong>Software / Device:</strong> This can reveal the camera model (e.g., "iPhone 14 Pro") or the software used to create or edit the file (e.g., "Adobe Photoshop"). This helps in attributing the file's origin.</li>
                        </ul>
                    </div>
                    <!-- Steganography Analyzer Content -->
                    <div class="guide-tab-content" id="guide-stego">
                        <div class="guide-header">
                            <h4><i class="fas fa-eye-slash"></i> Steganography</h4>
                            <button class="secondary" onclick="highlightToolCard('stego-card')"><i class="fas fa-crosshairs"></i> Highlight on Page</button>
                        </div>
                        <h5>What It Does</h5>
                        <p>Looks for data that may be concealed within an image using a common technique called LSB (Least Significant Bit) steganography.</p>
                        <h5>How to Interpret the Results</h5>
                        <ul>
                            <li><strong>Bit Plane:</strong> An image is made of color channels (Red, Green, Blue, Alpha). Each color's value is a number from 0-255, which is 8 bits of data. This tool isolates a single "bit plane" (e.g., all the 1st bits, or all the 8th bits) across one channel.</li>
                            <li><strong>Bit Plane Entropy:</strong> This is the key indicator. A bit plane from a normal, un-tampered image should have very low, non-random entropy. If the entropy is very high (close to 1.0), it means the data in that plane is highly random. This is a strong sign that encrypted or compressed data has been hidden there.</li>
                            <li><strong>Visual Preview:</strong> The black and white image shows you what the isolated bit plane looks like. A normal plane might show a faint outline of the original image. A plane containing hidden data will often look like random TV static.</li>
                        </ul>
                    </div>
                    <!-- Password Audit Content -->
                    <div class="guide-tab-content" id="guide-password">
                        <div class="guide-header">
                            <h4><i class="fas fa-key"></i> Password Audit</h4>
                            <button class="secondary" onclick="highlightToolCard('password-card')"><i class="fas fa-crosshairs"></i> Highlight on Page</button>
                        </div>
                        <h5>What It Does</h5>
                        <p>Measures the objective strength of a password against modern cracking techniques.</p>
                        <h5>How to Interpret the Results</h5>
                        <ul>
                            <li><strong>Password Entropy (bits):</strong> This is the most important metric. It measures the password's unpredictability. Higher is exponentially better.
                                <ul>
                                    <li><strong>&lt; 40 bits:</strong> Very Weak</li>
                                    <li><strong>40-60 bits:</strong> Weak</li>
                                    <li><strong>60-80 bits:</strong> Moderate</li>
                                    <li><strong>80-100 bits:</strong> Strong</li>
                                    <li><strong>&gt; 100 bits:</strong> Very Strong</li>
                                </ul>
                            </li>
                            <li><strong>Estimated Crack Time:</strong> This translates entropy into a practical, real-world metric. It's an estimate of how long it would take a powerful cracking rig (capable of billions of guesses per second) to find the password.</li>
                            <li><strong>Recommendations:</strong> The tool provides simple, actionable advice based on what the password lacks (e.g., "Add symbols," "Increase length").</li>
                        </ul>
                    </div>
                    <!-- Network Log Analyzer Content -->
                    <div class="guide-tab-content" id="guide-network">
                        <div class="guide-header">
                            <h4><i class="fas fa-network-wired"></i> Network Log Analyzer</h4>
                            <button class="secondary" onclick="highlightToolCard('network-card')"><i class="fas fa-crosshairs"></i> Highlight on Page</button>
                        </div>
                        <h5>What It Does</h5>
                        <p>Scans raw system or network logs, intelligently connecting individual lines to identify sophisticated, multi-step threats.</p>
                        <h5>How to Interpret the Results</h5>
                        <ul>
                            <li><strong>Correlated Threats:</strong> This is the core of the tool. It doesn't just find single bad lines; it understands context. For example, it will see 20 failed logins followed by one successful login from the same IP and flag it as a "Brute-Force Attack (Successful)", which is far more critical than 20 failed logins alone.</li>
                            <li><strong>Threat Score & Level:</strong> A calculated score that represents the overall risk level of the entire log file. This helps you prioritize investigations. A "CRITICAL" level indicates an active, successful compromise is likely.</li>
                            <li><strong>IP Watchlist:</strong> This allows you to provide your own list of known-bad IP addresses. The tool will then flag any and all activity from these IPs as a CRITICAL threat, making it easy to spot repeat offenders or track specific actors.</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- NEW: Toast Notification Container -->
    <div id="toast-container"></div>

    <canvas id="chart-canvas" width="400" height="200" style="display:none;"></canvas>

    <script>
        // --- GLOBAL STATE & INITIALIZATION ---
        let analysisResults = {};
        let chainOfCustody = [];
        let aiSummaryForReport = "";
        let lastAiResponse = "";
        let chatHistory = [];
        let mapInstance = null;
        let currentFileForHexView = null;

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        // --- NEW: Security Hardening - HTML Sanitizer ---
        function sanitizeHTML(str) {
            const temp = document.createElement('div');
            temp.textContent = str;
            return temp.innerHTML;
        }

        const threatDatabase = {
            "275a021bbfb6489e54d471899f7db9d1663fc695ec2fe2a2c4538aabf651fd0f": "WannaCry Ransomware",
            "e889544aff85ffaf8b0d0da705105dee7c97fe266fee5ae42d97b3af8d372185": "Emotet Trojan",
            "1a1a9999a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1a1": "EICAR Test File"
        };

        document.addEventListener('DOMContentLoaded', () => {
            // --- NEW: Forensic Guide Modal Logic ---
            const helpBtn = document.getElementById('help-guide-btn');
            const guideModal = document.getElementById('guide-modal');
            if (helpBtn && guideModal) {
                helpBtn.addEventListener('click', () => {
                    guideModal.classList.add('active');
                });
            }

            const guideTabs = document.querySelectorAll('.guide-tab-btn');
            const guideContents = document.querySelectorAll('.guide-tab-content');

            guideTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    // Deactivate all
                    guideTabs.forEach(t => t.classList.remove('active'));
                    guideContents.forEach(c => c.classList.remove('active'));

                    // Activate clicked tab and corresponding content
                    tab.classList.add('active');
                    const tabId = tab.dataset.tab;
                    document.getElementById(`guide-${tabId}`).classList.add('active');
                });
            });


            const themeToggle = document.getElementById('theme-toggle');
            const animationToggle = document.getElementById('animation-toggle');
            const body = document.body;

            function applyTheme(theme) {
                if (theme === 'light') {
                    body.classList.add('light-theme');
                    if (themeToggle) themeToggle.checked = true;
                } else {
                    body.classList.remove('light-theme');
                    if (themeToggle) themeToggle.checked = false;
                }
                if (typeof updateConstellationColors === 'function') {
                    updateConstellationColors();
                }
                // NEW: Update map tiles if map is active
                if (mapInstance) {
                    updateMapTheme();
                }
            }

            // Load theme preference on startup
            const savedTheme = localStorage.getItem('theme');
            const prefersLight = window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches;
            applyTheme(savedTheme || (prefersLight ? 'light' : 'dark'));

            themeToggle.addEventListener('change', () => {
                const newTheme = themeToggle.checked ? 'light' : 'dark';
                localStorage.setItem('theme', newTheme);
                applyTheme(newTheme);
            });

            // --- NEW: Animation Setting ---
            const animationsDisabled = localStorage.getItem('animationsDisabled') === 'true';
            if (animationToggle) {
                animationToggle.checked = animationsDisabled;
                if (animationsDisabled) {
                    body.classList.add('no-animations');
                }
                animationToggle.addEventListener('change', () => {
                    localStorage.setItem('animationsDisabled', animationToggle.checked);
                    alert('Background animation setting changed. The page will reload to apply it.');
                    location.reload();
                });
            }

            // --- NEW: Default User Settings ---
            const settingInvestigatorName = document.getElementById('setting-investigator-name');
            const settingOrgName = document.getElementById('setting-org-name');
            const reportInvestigatorName = document.getElementById('investigator-name');
            const reportOrgName = document.getElementById('org-name');

            // Listen for changes in the settings card and update localStorage + report card
            settingInvestigatorName.addEventListener('input', () => {
                const name = settingInvestigatorName.value;
                localStorage.setItem('defaultInvestigatorName', name);
                if (reportInvestigatorName) {
                    reportInvestigatorName.value = name;
                }
            });

            settingOrgName.addEventListener('input', () => {
                const org = settingOrgName.value;
                localStorage.setItem('defaultOrgName', org);
                if (reportOrgName) {
                    reportOrgName.value = org;
                }
            });

            // --- Intersection Observer for scroll-in animations ---
            const observerOptions = {
                root: null, // Use the viewport as the root
                rootMargin: '0px',
                threshold: 0.1 // Trigger when 10% of the element is visible
            };

            const observer = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.classList.add('is-visible');
                        observer.unobserve(entry.target); // Ensure animation only runs once
                    }
                });
            }, observerOptions);

            document.querySelectorAll('.tool-card').forEach(card => {
                observer.observe(card);

                // NEW: Add glare effect listener
                // This is already efficient, but we can ensure it only runs when needed
                let animationFrameId = null;
                const handleMouseMove = (e) => {
                    const rect = card.getBoundingClientRect();
                    card.style.setProperty('--mouse-x', `${e.clientX - rect.left}px`);
                    card.style.setProperty('--mouse-y', `${e.clientY - rect.top}px`);
                };
                card.addEventListener('mousemove', e => {
                    const rect = card.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    card.style.setProperty('--mouse-x', `${x}px`);
                    card.style.setProperty('--mouse-y', `${y}px`);
                });
                card.addEventListener('mouseleave', () => {
                    card.style.setProperty('--mouse-x', `50%`);
                    card.style.setProperty('--mouse-y', `50%`);
                });

                // Pause background animation when tab is not visible
                document.addEventListener('visibilitychange', () => { isAnimationPaused = document.hidden; });
            });

            // --- Drag and Drop File Input Logic ---
            document.querySelectorAll('input[type="file"]').forEach(fileInput => {
                const dropZone = fileInput.closest('.input-group');
                if (!dropZone) return;

                // Add a visual cue
                if (!dropZone.querySelector('.drop-zone-text')) {
                    const p = document.createElement('p');
                    p.textContent = 'or drag & drop file';
                    p.style.textAlign = 'center';
                    p.style.color = 'var(--text-secondary)';
                    p.style.fontSize = '0.8rem';
                    p.style.marginTop = '0.5rem';
                    p.style.pointerEvents = 'none'; // Make sure it doesn't interfere with clicks
                    p.classList.add('drop-zone-text');
                    fileInput.insertAdjacentElement('afterend', p);
                }

                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    dropZone.addEventListener(eventName, preventDefaults, false);
                });

                ['dragenter', 'dragover'].forEach(eventName => {
                    dropZone.addEventListener(eventName, () => dropZone.classList.add('drag-over'), false);
                });

                ['dragleave', 'drop'].forEach(eventName => {
                    dropZone.addEventListener(eventName, () => dropZone.classList.remove('drag-over'), false);
                });

                dropZone.addEventListener('drop', (e) => {
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        fileInput.files = files;
                        const event = new Event('change', { bubbles: true });
                        fileInput.dispatchEvent(event);
                    }
                }, false);

                // Add a click listener to allow re-selecting the same file, which will trigger the 'change' event
                fileInput.addEventListener('click', (e) => {
                    e.target.value = null;
                });
            });
            ['dragenter', 'dragover', 'drop'].forEach(eventName => { document.body.addEventListener(eventName, preventDefaults, false); });

            // --- Modal Usability Enhancements ---
            // Close modals with the Escape key
            document.addEventListener('keydown', (event) => {
                if (event.key === 'Escape') {
                    const activeModal = document.querySelector('.modal-overlay.active');
                    if (activeModal) {
                        activeModal.classList.remove('active');
                    }
                }
            });

            // Close modals by clicking on the overlay
            document.querySelectorAll('.modal-overlay').forEach(overlay => {
                overlay.addEventListener('click', (event) => {
                    // Only close if the click is on the overlay itself, not its children
                    if (event.target === overlay) {
                        overlay.classList.remove('active');
                    }
                });
            });

            document.getElementById('timeline-view-btn').addEventListener('click', openTimelineModal);
            document.getElementById('add-coc-entry-btn').addEventListener('click', openAddCocModal);

            // Add simple feedback for file selection
            document.querySelectorAll('input[type="file"]').forEach(input => {
                input.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const output = e.target.closest('.tool-card-content').querySelector('.output');
                        if (output) output.innerHTML = `File '${file.name}' selected. Ready for analysis.`;
                    }
                });
            });

            resetSession();

            // --- NEW: Single View Mode Logic ---
            const singleViewToggleBtn = document.getElementById('single-view-toggle-btn');
            const toolSection = document.querySelector('.tool-section');
            const toolNavigator = document.querySelector('.tool-navigator');
            const toolNavLinks = document.querySelectorAll('.tool-navigator .navigator-list a');
            const toolCards = document.querySelectorAll('.tool-section .tool-card');
            const grid = document.querySelector('.tool-grid');

            if (singleViewToggleBtn && toolSection && toolNavigator && toolNavLinks.length > 0 && grid) {
                singleViewToggleBtn.addEventListener('click', () => {
                    toolSection.classList.toggle('single-view');
                    singleViewToggleBtn.classList.toggle('active');

                    const isSingleView = toolSection.classList.contains('single-view');
                    toolNavigator.style.display = isSingleView ? 'block' : 'none';

                    if (isSingleView) {
                        // Deactivate all, then activate the first one
                        toolCards.forEach(card => card.classList.remove('active-tool'));
                        if (toolCards.length > 0) {
                            toolCards[0].classList.add('active-tool');
                        }
                        // Also update nav links
                        toolNavLinks.forEach(link => link.classList.remove('active'));
                        if (toolNavLinks.length > 0) {
                            toolNavLinks[0].classList.add('active');
                        }
                    } else {
                        // When exiting single view, remove active state from all
                        toolCards.forEach(card => card.classList.remove('active-tool'));
                        grid.style.height = ''; // Reset height
                    }
                });

                toolNavLinks.forEach(link => {
                    link.addEventListener('click', (e) => {
                        e.preventDefault();
                        const targetId = link.getAttribute('href');
                        const targetCard = document.querySelector(targetId);
                        const currentActiveCard = document.querySelector('.tool-section .tool-card.active-tool');

                        if (targetCard && currentActiveCard !== targetCard) {
                            // 1. Set grid to current card's height to prevent page jump
                            if (currentActiveCard) {
                                grid.style.height = `${currentActiveCard.offsetHeight}px`;
                            }

                            // 2. Update nav links
                            toolNavLinks.forEach(l => l.classList.remove('active'));
                            link.classList.add('active');

                            // 3. Hide current card and show target card
                            if (currentActiveCard) {
                                currentActiveCard.classList.remove('active-tool');
                            }
                            toolCards.forEach(card => card.classList.remove('active-tool'));
                            targetCard.classList.add('active-tool');

                            // 4. Animate grid height to new card's height
                            requestAnimationFrame(() => {
                                const newHeight = targetCard.offsetHeight;
                                grid.style.height = `${newHeight}px`;

                                // 5. Reset grid height after animation
                                grid.addEventListener('transitionend', () => {
                                    grid.style.transition = '';
                                    grid.style.height = '';
                                }, { once: true });
                            });
                        }
                    });
                });
            }

            // --- NEW: Interactive Sidebar Logic ---
            const sidebarWrapper = document.querySelector('.sidebar-content-wrapper');
            const sidebarNavLinks = document.querySelectorAll('.sidebar-navigator .navigator-list a');
            const sidebarCards = document.querySelectorAll('.sidebar-content-wrapper .tool-card');

            if (sidebarWrapper && sidebarNavLinks.length > 0 && sidebarCards.length > 0) {
                // 1. Smooth scrolling on click
                sidebarNavLinks.forEach(link => {
                    link.addEventListener('click', function(e) {
                        e.preventDefault();
                        const targetId = this.getAttribute('href');
                        const targetElement = document.querySelector(targetId);
                        if (targetElement) {
                            targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        }
                    });
                });

                // 2. Intersection Observer to highlight active link
                const observerOptions = {
                    root: sidebarWrapper,
                    rootMargin: '0px 0px -50% 0px',
                    threshold: 0.1
                };

                const sidebarObserver = new IntersectionObserver((entries, observer) => {
                    entries.forEach(entry => {
                        const targetId = `#${entry.target.id}`;
                        const correspondingLink = document.querySelector(`.sidebar-navigator a[href="${targetId}"]`);
                        if (entry.isIntersecting && correspondingLink) {
                            sidebarNavLinks.forEach(link => link.classList.remove('active'));
                            correspondingLink.classList.add('active');
                        }
                    });
                }, observerOptions);

                sidebarCards.forEach(card => sidebarObserver.observe(card));
            }
        });

        // --- NEW: Toast Notification System ---
        function showToast(message, type = 'info') {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            
            let iconClass = 'fas fa-info-circle';
            if (type === 'success') iconClass = 'fas fa-check-circle';
            if (type === 'danger') iconClass = 'fas fa-exclamation-triangle';

            toast.innerHTML = `<i class="${iconClass}"></i><span>${message}</span>`;
            container.appendChild(toast);

            // Trigger the fade-out animation which also removes the element
            toast.addEventListener('animationend', (e) => {
                if (e.animationName === 'fadeOutToast') {
                    toast.remove();
                }
            });
        }

        // --- NEW: Interactive Guide Feature ---
        function highlightToolCard(targetId) {
            const modal = document.getElementById('guide-modal');
            const targetCard = document.getElementById(targetId);

            if (!targetCard) {
                console.error(`Highlight target not found: ${targetId}`);
                return;
            }

            // Close the modal
            if (modal) {
                modal.classList.remove('active');
            }

            // Scroll to the card and apply highlight
            targetCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
            targetCard.classList.add('highlight-pulse');
            targetCard.addEventListener('animationend', () => { targetCard.classList.remove('highlight-pulse'); }, { once: true });
        }

        // --- NEW: Secure Chain of Custody Verification ---
        function verifyChainOfCustody(showSuccessToast = false) {
            if (chainOfCustody.length === 0) {
                if (showSuccessToast) showToast('Chain is empty, nothing to verify.', 'info');
                return;
            }
            let isValid = true;
            // The chain is stored newest-first, so we iterate backwards to check from oldest to newest.
            for (let i = chainOfCustody.length - 1; i >= 0; i--) {
                const entry = chainOfCustody[i];
                
                // Determine the previous hash. For the oldest entry (the genesis block), it's a known string of zeros.
                const expectedPreviousHash = (i === chainOfCustody.length - 1) 
                    ? '0'.repeat(64) 
                    : chainOfCustody[i + 1].hash;

                if (entry.previousHash !== expectedPreviousHash) {
                    isValid = false;
                    break;
                }

                // Recalculate the current entry's hash to see if its data has been tampered with.
                const entryString = `${entry.id}|${entry.action}|${entry.target}|${entry.status}|${entry.type}|${entry.details}|${entry.timestamp}|${entry.previousHash}`;
                const recalculatedHash = CryptoJS.SHA256(entryString).toString();

                if (entry.hash !== recalculatedHash) {
                    isValid = false;
                    break;
                }
            }

            if (isValid) {
                if (showSuccessToast) showToast('Chain of Custody integrity verified successfully!', 'success');
            } else {
                showToast('CRITICAL: Chain of Custody has been broken or tampered with!', 'danger');
            }
        }

        function resetSession() {
            analysisResults = { sessionId: `NITTALA-${Math.floor(1000 + Math.random() * 9000)}` };
            chainOfCustody = [];
            chatHistory = [{
                role: "user",
                parts: [{ text: "You are a world-class digital forensics expert and AI assistant called N.I.T.T.A.L.A. Your purpose is to assist users in analyzing digital evidence. Be concise, accurate, and provide actionable advice. When asked to summarize, use the provided analysis data. Do not mention you are a language model." }]
            }, {
                role: "model",
                parts: [{ text: "Understood. I am the N.I.T.T.A.L.A. AI, ready to assist with forensic analysis." }]
            }];
            document.getElementById('case-name').value = '';
            document.getElementById('case-type').value = '';
            document.getElementById('case-notes-textarea').value = '';

            // Apply default user settings from localStorage to both settings and report cards
            const defaultInvestigator = localStorage.getItem('defaultInvestigatorName') || '';
            const defaultOrg = localStorage.getItem('defaultOrgName') || '';
            document.getElementById('investigator-name').value = defaultInvestigator;
            document.getElementById('org-name').value = defaultOrg;
            document.getElementById('setting-investigator-name').value = defaultInvestigator;
            document.getElementById('setting-org-name').value = defaultOrg;

            addCoCEntry('Session Started', 'System', 'low', `New investigation session initialized.`);
        }

        function clearAllSettings() {
            if (confirm('Are you sure you want to clear all saved settings? This will remove your saved theme and default investigator info. This action cannot be undone.')) {
                localStorage.removeItem('theme');
                localStorage.removeItem('defaultInvestigatorName');
                localStorage.removeItem('defaultOrgName');
                alert('All saved settings have been cleared. The page will now reload to apply changes.');
                location.reload();
            }
        }

        function clearToolState(cardId) {
            const card = document.getElementById(cardId);
            if (!card) return;

            // Reset file inputs
            card.querySelectorAll('input[type="file"]').forEach(input => {
                input.value = '';
            });

            // Reset text/password inputs and textareas
            card.querySelectorAll('input[type="password"], textarea').forEach(input => {
                input.value = '';
            });

            // Reset output divs to their default text
            const output = card.querySelector('.output, #network-output');
            if (output) {
                const defaultTexts = {
                    'integrity-card': 'Select a file and click "Full Scan".',
                    'comparison-card': 'Select two files and click "Compare Files".',
                    'metadata-card': 'Select a file and click "Analyze Metadata".',
                    'stego-card': 'Select an image and click "Analyze Bit Plane".',
                    'password-card': 'Enter a password and click "Full Analysis".',
                    'network-card': '' // Use CSS placeholder
                };
                output.innerHTML = defaultTexts[cardId] || 'Output will appear here.';
            }

            // Hide and destroy charts
            card.querySelectorAll('canvas').forEach(canvas => {
                destroyChart(canvas.id);
                canvas.style.display = 'none';
            });

            // Hide AI buttons
            card.querySelectorAll('#meta-ai-btn, #net-ai-btn').forEach(btn => {
                btn.style.display = 'none';
            });

            // Specific resets for special tools
            if (cardId === 'integrity-card') {
                const hexViewer = document.getElementById('hex-viewer-output');
                if (hexViewer) {
                    hexViewer.innerHTML = '';
                    hexViewer.style.display = 'none';
                }
                const carveBtn = document.getElementById('find-carve-btn');
                const carveOutput = document.getElementById('carve-output');
                if (carveBtn) carveBtn.disabled = true;
                if (carveOutput) {
                    carveOutput.style.display = 'none';
                    carveOutput.innerHTML = '';
                }
                currentFileForHexView = null;
            }
            if (cardId === 'metadata-card') {
                const mapContainer = document.getElementById('map-container');
                if (mapContainer) mapContainer.style.display = 'none';
                if (mapInstance) {
                    mapInstance.remove();
                    mapInstance = null;
                }
            }
            if (cardId === 'password-card') {
                const scoreData = calculatePasswordScore('');
                renderPasswordStrengthBar(scoreData);
            }
        }

        function destroyChart(canvasId) {
            const canvas = document.getElementById(canvasId);
            if (canvas && canvas.chart) {
                canvas.chart.destroy();
                canvas.chart = null;
            }
        }

        async function runAnalysis(cardId, analysisFn) {
            const loader = document.querySelector(`#${cardId} .card-loader`);
            const buttons = document.querySelectorAll(`#${cardId} button`);
            loader.classList.add('active');
            buttons.forEach(b => b.disabled = true);
            
            try {
                await new Promise(res => setTimeout(res, 50));
                await analysisFn();
            } catch (error) {
                console.error(`Analysis failed for ${cardId}:`, error);
                const output = document.querySelector(`#${cardId} .output`);
                if(output) output.innerHTML = `<span class="danger">An unexpected error occurred: ${error.message}</span>`;
            } finally {
                loader.classList.remove('active');
                buttons.forEach(b => b.disabled = false);
            }
        }

        function toggleHexViewer(event) {
            event.preventDefault();
            const hexViewer = document.getElementById('hex-viewer-output');
            const link = event.target;
            if (!hexViewer) return;
            const isVisible = hexViewer.style.display !== 'none';
            hexViewer.style.display = isVisible ? 'none' : 'block';
            link.textContent = isVisible ? 'Show Raw Hex View' : 'Hide Raw Hex View';
            if (!isVisible) hexViewer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        function copyToClipboard(text, buttonElement) {
            navigator.clipboard.writeText(text).then(() => {
                const originalHTML = buttonElement.innerHTML;
                buttonElement.innerHTML = `<i class="fas fa-check"></i> Copied!`;
                buttonElement.disabled = true;
                setTimeout(() => {
                    buttonElement.innerHTML = originalHTML;
                    buttonElement.disabled = false;
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy text: ', err);
                alert('Failed to copy text to clipboard.');
            });
        }

        function hexToRgb(hex) {
            if (!hex) return null;
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        // Helper function to get theme colors for charts
        function getChartColors() {
            const style = getComputedStyle(document.body);
            return {
                primaryText: style.getPropertyValue('--text-primary').trim(),
                secondaryText: style.getPropertyValue('--text-secondary').trim(),
                borderColor: style.getPropertyValue('--border-color').trim(),
                primaryBg: style.getPropertyValue('--primary-bg').trim()
            };
        }

        // --- GEMINI API INTEGRATION ---
        async function callGemini(prompt) {
            // The API call is now proxied through our own backend to protect the API key.
            const apiUrl = '/api/gemini';
            
            chatHistory.push({ role: "user", parts: [{ text: prompt }] });

            const payload = { contents: chatHistory };

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorResult = await response.json().catch(() => ({ error: 'Could not parse error response from server.' }));
                    console.error("Backend proxy error:", errorResult);
                    if (response.status === 500 && errorResult.error && errorResult.error.includes('API key is not configured')) {
                         return "Error: The backend server is running, but the GEMINI_API_KEY is missing in the .env file on the server. Please configure it.";
                    }
                    throw new Error(`Backend proxy failed with status: ${response.status}. ${errorResult.error || ''}`);
                }

                const result = await response.json();
                
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const text = result.candidates[0].content.parts[0].text;
                    chatHistory.push({ role: "model", parts: [{ text: text }] });
                    return text;
                } else if (result.error) {
                    const errorMessage = result.error.message || JSON.stringify(result.error);
                    console.error("API returned an error:", errorMessage);
                    return `Error from AI Service: ${sanitizeHTML(errorMessage)}`;
                } else {
                    console.error("Unexpected API response structure:", result);
                    return "Error: Received an invalid response from the AI. Please check the console.";
                }
            } catch (error) {
                console.error("Error calling backend proxy:", error);
                return `Error: Could not communicate with the local backend server. Is it running? Details: ${sanitizeHTML(error.message)}`;
            }
        }


        // --- AI CHATBOT IMPLEMENTATION ---
        function quickAction(message) {
             document.getElementById('ai-chat-input').value = message;
            sendChatMessage();
        }

        function addAiSummaryToReport() {
            if (lastAiResponse) {
                aiSummaryForReport = lastAiResponse;
                alert("AI summary has been staged and will be added to the Executive Summary in the next PDF report.");
            } else {
                alert("No AI summary is available. Please ask the AI to summarize the findings first.");
            }
        }

        async function sendChatMessage() {
            const input = document.getElementById('ai-chat-input');
            const sendBtn = document.getElementById('ai-chat-send-btn');
            const message = input.value.trim();
            if (!message) return;

            appendChatMessage(message, 'user');
            input.value = '';
            input.disabled = true;
            sendBtn.disabled = true;
            sendBtn.innerHTML = `<div class="loading-spinner" style="width: 1em; height: 1em; border-width: 2px;"></div>`;

            let prompt = message;
            if (message.toLowerCase().includes('summarize') || message.toLowerCase().includes('suggest')) {
                prompt += `\n\nHere is the current analysis context in JSON format:\n${JSON.stringify(analysisResults)}`;
            }
            
            const aiResponse = await callGemini(prompt);
            lastAiResponse = aiResponse; 
            appendChatMessage(aiResponse, 'ai');

            input.disabled = false;
            sendBtn.disabled = false;
            sendBtn.innerHTML = `<i class="fas fa-paper-plane"></i>`;
        }

        function appendChatMessage(message, sender) {
            const chatWindow = document.getElementById('ai-chat-window');
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${sender}-message`;
            // Sanitize the message to prevent XSS, then replace newlines with <br> for formatting.
            messageDiv.innerHTML = sanitizeHTML(message).replace(/\n/g, '<br>'); 
            chatWindow.appendChild(messageDiv);
            chatWindow.scrollTop = chatWindow.scrollHeight;
        }

        // --- TOOL FUNCTIONS ---

        function generateHash() {
            return new Promise((resolve, reject) => {
                const fileInput = document.getElementById('file-upload');
                const output = document.getElementById('hash-output');
                const progressBar = document.querySelector('#integrity-card .progress-bar-inner');
                progressBar.style.width = '0%';

                if (!fileInput.files[0]) {
                    output.innerHTML = '<span class="danger">Please select a file first.</span>';
                    reject(new Error('No file selected.'));
                    return;
                }
                const file = fileInput.files[0];
                currentFileForHexView = file;
                addCoCEntry('Evidence Acquired', file.name, 'low', `File staged for integrity analysis. Size: ${(file.size / 1024).toFixed(2)} KB`);
                document.getElementById('find-carve-btn').disabled = false;

                // --- NEW: Web Worker for background processing ---
                const workerCode = `
                    self.importScripts('https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js');

                    function getFileType(bytes) {
                        const signatures = { "FFD8FFE0": "JPEG image", "89504E47": "PNG image", "47494638": "GIF image", "25504446": "PDF document", "504B0304": "ZIP archive", "4D5A": "Windows PE file (EXE/DLL)" };
                        const hex = Array.from(bytes.slice(0, 4)).map(b => b.toString(16).padStart(2, '0').toUpperCase()).join('');
                        for (const sig in signatures) { if (hex.startsWith(sig)) return signatures[sig]; }
                        return "Unknown / Generic data";
                    }

                    function calculateEntropy(data) {
                        if (data.length === 0) return 0;
                        const map = {};
                        for (const byte of data) { map[byte] = (map[byte] || 0) + 1; }
                        let entropy = 0;
                        const len = data.length;
                        for (const byte in map) { const p = map[byte] / len; entropy -= p * Math.log2(p); }
                        return entropy;
                    }

                    self.onmessage = async (e) => {
                        const { file, threatDatabase } = e.data;
                        const chunkSize = 1024 * 1024 * 4;
                        const sha256Hasher = CryptoJS.algo.SHA256.create();
                        const sha1Hasher = CryptoJS.algo.SHA1.create();
                        const md5Hasher = CryptoJS.algo.MD5.create();
                        const frequencies = new Array(256).fill(0);
                        let totalBytesProcessed = 0;
                        const plotBlockSize = Math.max(256, Math.floor(file.size / 512));
                        let blockEntropies = [];
                        let currentPlotBlock = new Uint8Array(plotBlockSize);
                        let currentPlotBlockIndex = 0;

                        const firstBytes = new Uint8Array(await file.slice(0, 4).arrayBuffer());
                        const fileType = getFileType(firstBytes);
                        const hexViewBytes = new Uint8Array(await file.slice(0, 512).arrayBuffer());

                        for (let offset = 0; offset < file.size; offset += chunkSize) {
                            const chunkBuffer = await file.slice(offset, offset + chunkSize).arrayBuffer();
                            const chunkBytes = new Uint8Array(chunkBuffer);
                            const wordArray = CryptoJS.lib.WordArray.create(chunkBytes);
                            sha256Hasher.update(wordArray);
                            sha1Hasher.update(wordArray);
                            md5Hasher.update(wordArray);
                            for (const byte of chunkBytes) {
                                frequencies[byte]++;
                                currentPlotBlock[currentPlotBlockIndex++] = byte;
                                if (currentPlotBlockIndex === plotBlockSize) {
                                    blockEntropies.push(calculateEntropy(currentPlotBlock));
                                    currentPlotBlockIndex = 0;
                                }
                            }
                            totalBytesProcessed += chunkBytes.length;
                            self.postMessage({ type: 'progress', value: (totalBytesProcessed / file.size) * 100 });
                        }

                        if (currentPlotBlockIndex > 0) {
                            blockEntropies.push(calculateEntropy(currentPlotBlock.slice(0, currentPlotBlockIndex)));
                        }

                        const hashes = {
                            sha256: sha256Hasher.finalize().toString(),
                            sha1: sha1Hasher.finalize().toString(),
                            md5: md5Hasher.finalize().toString()
                        };

                        let entropy = 0;
                        for (const freq of frequencies) { if (freq > 0) { const p = freq / file.size; entropy -= p * Math.log2(p); } }

                        const threatInfo = threatDatabase[hashes.sha256];
                        const isMalicious = !!threatInfo;

                        self.postMessage({ type: 'result', data: { file, hashes, entropy, frequencies, blockEntropies, plotBlockSize, fileType, hexViewBytes, isMalicious, threatInfo } });
                        self.close();
                    };
                `;

                const blob = new Blob([workerCode], { type: 'application/javascript' });
                const worker = new Worker(URL.createObjectURL(blob));

                worker.onmessage = (e) => {
                    const { type, data, value } = e.data;
                    if (type === 'progress') {
                        progressBar.style.width = `${value}%`;
                    } else if (type === 'result') {
                        progressBar.style.width = '100%';
                        const { file, hashes, entropy, frequencies, blockEntropies, plotBlockSize, fileType, hexViewBytes, isMalicious, threatInfo } = data;
                        
                        let resultHTML = `--- File Integrity & Threat Report ---\nFilename:      ${sanitizeHTML(file.name)}\nFile Size:     ${(file.size / 1024).toFixed(2)} KB\nIdentified Type: ${sanitizeHTML(fileType)}\n\n--- Cryptographic Hashes ---\nMD5:    ${hashes.md5}\nSHA-1:  ${hashes.sha1}\nSHA-256: <span class="info">${hashes.sha256}</span>\n\n--- Threat Intelligence Analysis ---\n`;
                        resultHTML += isMalicious ? `Status: <span class="danger">KNOWN THREAT DETECTED</span>\nMatch:  ${sanitizeHTML(threatInfo)}\n\n` : `Status: <span class="success">No known threats found in database.</span>\n\n`;

                        let entropyAssessment, entropyColor, entropyInterpretation;
                        const isCompressedType = fileType.includes('JPEG') || fileType.includes('PNG') || fileType.includes('GIF') || fileType.includes('ZIP');
                        if (isCompressedType) {
                            if (entropy > 7.0) { entropyAssessment = 'Normal (Compressed)'; entropyColor = 'success'; } else { entropyAssessment = 'Moderate'; entropyColor = 'warning'; }
                            entropyInterpretation = `High entropy is expected for compressed file types like ${sanitizeHTML(fileType)}.`;
                        } else {
                            if (entropy > 7.5) { entropyAssessment = 'HIGH'; entropyColor = 'danger'; } else if (entropy < 6.0) { entropyAssessment = 'LOW'; entropyColor = 'warning'; } else { entropyAssessment = 'Normal'; entropyColor = 'success'; }
                            entropyInterpretation = `An entropy level of '${entropyAssessment}' for a ${sanitizeHTML(fileType)} can be significant. High entropy may indicate encryption or packing.`;
                        }
                        resultHTML += `--- Entropy Analysis ---\nShannon Entropy (Overall): ${entropy.toFixed(4)} / 8.0\nAssessment:              <span class="${entropyColor}">${entropyAssessment}</span>\n\n<div class="interpretation"><strong>Interpretation:</strong> ${entropyInterpretation} <a href="#" onclick="toggleHexViewer(event)" class="show-more-link">Show Raw Hex View</a></div>`;

                        output.innerHTML = resultHTML;
                        renderHexView(hexViewBytes);
                        renderEntropyChart(frequencies);
                        renderEntropyPlotChart(blockEntropies, plotBlockSize);
                        const maxBlockEntropy = Math.max(...blockEntropies);
                        const minBlockEntropy = Math.min(...blockEntropies);

                        analysisResults.fileHash = { fileName: file.name, hashes, isMalicious, threatName: threatInfo || 'N/A', entropy, fileType, fileSize: file.size, blockEntropy: { min: minBlockEntropy, max: maxBlockEntropy, average: blockEntropies.reduce((a, b) => a + b, 0) / blockEntropies.length }, entropyAssessment };
                        addCoCEntry('File Threat Scan', file.name, isMalicious ? 'high' : 'low', `Scan complete. Threat status: ${isMalicious ? 'Positive' : 'Negative'}. Entropy: ${entropy.toFixed(2)}`, 'auto');
                        
                        worker.terminate();
                        URL.revokeObjectURL(blob);
                        resolve();
                    }
                };

                worker.onerror = (err) => {
                    output.innerHTML = `<span class="danger">An error occurred in the analysis worker: ${err.message}</span>`;
                    worker.terminate();
                    URL.revokeObjectURL(blob);
                    reject(err);
                };

                worker.postMessage({ file, threatDatabase });
            });
        }
        
        function renderEntropyChart(frequencies) {
            const chartCanvas = document.getElementById('entropy-chart');
            chartCanvas.style.display = 'block';
            destroyChart('entropy-chart');
            const chartColors = getChartColors();

            const ctx = chartCanvas.getContext('2d');
            chartCanvas.chart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: Array.from({length: 256}, (_, i) => i.toString(16).padStart(2, '0')),
                    datasets: [{
                        label: 'Byte Frequency Distribution',
                        data: frequencies,
                        backgroundColor: 'rgba(63, 131, 248, 0.5)',
                        borderColor: 'rgba(63, 131, 248, 1)',
                        borderWidth: 1,
                        barPercentage: 1.0,
                        categoryPercentage: 1.0
                    }]
                },
                options: {
                    plugins: {
                        legend: { display: false },
                        title: { display: true, text: 'Byte Frequency Distribution', color: chartColors.primaryText }
                    },
                    scales: {
                        x: { display: false },
                        y: { beginAtZero: true, ticks: { color: chartColors.secondaryText }, grid: { color: chartColors.borderColor } }
                    }
                }
            });
        }

        function renderEntropyPlotChart(blockEntropies, blockSize) {
            const chartCanvas = document.getElementById('byte-plot-chart');
            chartCanvas.style.display = 'block';
            destroyChart('byte-plot-chart');
            const chartColors = getChartColors();

            const ctx = chartCanvas.getContext('2d');
            chartCanvas.chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: blockEntropies.map((_, i) => i * blockSize),
                    datasets: [{
                        label: 'Block Entropy',
                        data: blockEntropies,
                        borderColor: 'rgba(245, 158, 11, 0.8)',
                        backgroundColor: 'rgba(245, 158, 11, 0.2)',
                        borderWidth: 1,
                        pointRadius: 0,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    plugins: {
                        legend: { display: false },
                        title: { display: true, text: `Entropy Plot (Block Size: ${blockSize} bytes)`, color: chartColors.primaryText }
                    },
                    scales: {
                        x: {
                            display: true,
                            title: { display: true, text: 'File Offset (bytes)', color: chartColors.secondaryText},
                            ticks: { color: chartColors.secondaryText },
                            grid: { color: chartColors.borderColor }
                        },
                        y: {
                            beginAtZero: true,
                            max: 8,
                            title: { display: true, text: 'Entropy (bits)', color: chartColors.secondaryText},
                            ticks: { color: chartColors.secondaryText },
                            grid: { color: chartColors.borderColor }
                        }
                    }
                }
            });
        }

        function calculateEntropy(data) {
            if (data.length === 0) return 0;
            const map = {};
            for (const byte of data) { map[byte] = (map[byte] || 0) + 1; }
            let entropy = 0;
            const len = data.length;
            for (const byte in map) {
                const p = map[byte] / len;
                entropy -= p * Math.log2(p);
            }
            return entropy;
        }

        function getFileType(bytes) {
            const signatures = {
                "FFD8FFE0": "JPEG image", "89504E47": "PNG image", "47494638": "GIF image",
                "25504446": "PDF document", "504B0304": "ZIP archive", "4D5A": "Windows PE file (EXE/DLL)"
            };
            const hex = Array.from(bytes.slice(0, 4)).map(b => b.toString(16).padStart(2, '0').toUpperCase()).join('');
            for (const sig in signatures) {
                if (hex.startsWith(sig)) return signatures[sig];
            }
            return "Unknown / Generic data";
        }

        // --- FILE CARVING LOGIC (IMPROVED) ---

        /**
         * Carving strategy: Find End of File by searching for a trailer signature.
         * @param {File} file The file object to search within.
         * @param {number} startOffset The offset to start searching from.
         * @param {object} options Options, including { trailer: 'hexstring', findLast: boolean }.
         * @returns {Promise<number>} The calculated end offset of the file, or -1 if not found.
         */
        async function findEndByTrailer(file, startOffset, options) {
            const trailerBytes = options.trailer.match(/.{1,2}/g).map(byte => parseInt(byte, 16));
            const trailerLen = trailerBytes.length;
            const searchChunkSize = 1024 * 512; // 512KB
            let lastFoundOffset = -1;

            for (let offset = startOffset; offset < file.size; offset += searchChunkSize) {
                const readStart = offset > startOffset ? offset - trailerLen : offset;
                const chunk = await file.slice(readStart, readStart + searchChunkSize + trailerLen).arrayBuffer();
                const bytes = new Uint8Array(chunk);

                for (let i = 0; i < bytes.length - trailerLen + 1; i++) {
                    let match = true;
                    for (let j = 0; j < trailerLen; j++) {
                        if (bytes[i + j] !== trailerBytes[j]) { match = false; break; }
                    }
                    if (match) {
                        lastFoundOffset = readStart + i + trailerLen;
                        if (!options.findLast) return lastFoundOffset;
                    }
                }
            }

            if (lastFoundOffset !== -1 && options.trailer === '2525454f46') { // %%EOF for PDF
                const checkBytes = new Uint8Array(await file.slice(lastFoundOffset, lastFoundOffset + 2).arrayBuffer());
                if (checkBytes.length > 0 && checkBytes[0] === 0x0A) lastFoundOffset++; // LF
                if (checkBytes.length > 1 && checkBytes[0] === 0x0D && checkBytes[1] === 0x0A) lastFoundOffset++; // CRLF
            }
            return lastFoundOffset;
        }

        /**
         * Carving strategy: Find End of Central Directory record for ZIP files.
         * This is more reliable than a simple trailer search.
         * @param {File} file The file object to search within.
         * @param {number} startOffset The offset where the ZIP header was found.
         * @returns {Promise<number>} The calculated end offset of the file, or -1 if not found.
         */
        async function findEndZip(file, startOffset, options) {
            const eocdSig = [0x50, 0x4b, 0x05, 0x06];
            const searchChunkSize = 65535 + 22; // Max ZIP comment size + EOCD record size
            const readStart = Math.max(startOffset, file.size - searchChunkSize);
            const chunk = await file.slice(readStart).arrayBuffer();
            const bytes = new Uint8Array(chunk);

            for (let i = bytes.length - 22; i >= 0; i--) {
                if (bytes[i] === eocdSig[0] && bytes[i+1] === eocdSig[1] && bytes[i+2] === eocdSig[2] && bytes[i+3] === eocdSig[3]) {
                    const commentLength = bytes[i + 20] | (bytes[i + 21] << 8);
                    return readStart + i + 22 + commentLength;
                }
            }
            return -1; // Not found
        }

        const fileSignaturesForCarving = {
            'JPEG': { hex: 'ffd8ffe0', ext: 'jpg', findEnd: findEndByTrailer, options: { trailer: 'ffd9' } },
            'JPEG_EXIF': { hex: 'ffd8ffe1', ext: 'jpg', findEnd: findEndByTrailer, options: { trailer: 'ffd9' } },
            'PNG': { hex: '89504e47', ext: 'png', findEnd: findEndByTrailer, options: { trailer: '49454e44ae426082' } },
            'GIF': { hex: '47494638', ext: 'gif', findEnd: findEndByTrailer, options: { trailer: '3b' } }, // Covers GIF87a and GIF89a
            'PDF': { hex: '25504446', ext: 'pdf', findEnd: findEndByTrailer, options: { trailer: '2525454f46', findLast: true } },
            'ZIP-based (ZIP, DOCX, etc.)': { hex: '504b0304', ext: 'zip', findEnd: findEndZip },
        };

        async function findAndCarveSignatures() {
            const output = document.getElementById('carve-output');
            const file = currentFileForHexView;
            if (!file) {
                output.style.display = 'block';
                output.innerHTML = '<span class="danger">Please run a "Full Scan" on a file first.</span>';
                return;
            }

            addCoCEntry('Signature Scan', file.name, 'medium', 'Initiated scan for embedded file signatures.');
            output.style.display = 'block';
            output.innerHTML = 'Scanning for known file headers... This may take a moment for large files.';

            const signatures = fileSignaturesForCarving;
            const sigBytes = {};
            for (const key in signatures) {
                sigBytes[key] = signatures[key].hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16));
            }

            const chunkSize = 1024 * 1024; // 1MB
            const maxSigLen = 8;
            let foundHeaders = [];

            for (let offset = 0; offset < file.size; offset += chunkSize) {
                const chunk = await file.slice(offset, offset + chunkSize + maxSigLen).arrayBuffer();
                const bytes = new Uint8Array(chunk);
                
                for (let i = 0; i < bytes.length; i++) {
                    for (const key in sigBytes) {
                        const sig = sigBytes[key];
                        if (i + sig.length > bytes.length) continue;
                        let match = true;
                        for (let j = 0; j < sig.length; j++) {
                            if (bytes[i + j] !== sig[j]) { match = false; break; }
                        }
                        if (match && !foundHeaders.some(h => h.offset === (offset + i))) { // Prevent adding duplicates for same offset
                            foundHeaders.push({ type: key, offset: offset + i });
                            i += sig.length - 1;
                        }
                    }
                }
            }

            if (foundHeaders.length === 0) {
                output.innerHTML = '<span class="success">No known file signatures found within the file.</span>';
                return;
            }

            let resultHTML = `Found ${foundHeaders.length} potential embedded file(s):\n\n`;
            foundHeaders.forEach(header => {
                const sigInfo = signatures[header.type];
                resultHTML += `<strong>- ${header.type.replace('_', ' ')}</strong> found at offset <span class="info">0x${header.offset.toString(16)}</span>\n`;
                resultHTML += `<button class="secondary" style="padding: 0.2rem 0.5rem; font-size: 0.8rem; margin: 0.2rem 0 0.8rem 1rem;" onclick="carveFile(${header.offset}, '${header.type}')">Carve File (.${sigInfo.ext})</button>\n`;
            });
            
            resultHTML += `<div class="interpretation" style="margin-top: 1rem;"><strong>Note:</strong> Carving attempts to find the end-of-file marker. If not found, it will prompt for a length. The resulting file may contain extra data.</div>`;
            output.innerHTML = resultHTML;
        }

        async function carveFile(startOffset, type) {
            const file = currentFileForHexView;
            const sigInfo = fileSignaturesForCarving[type];
            if (!file || !sigInfo) { alert('Error: Could not find file or signature info to carve.'); return; }

            let endOffset = -1;
            if (sigInfo.findEnd) {
                endOffset = await sigInfo.findEnd(file, startOffset, sigInfo.options);
            }

            if (endOffset === -1) {
                const userInput = prompt(`Could not automatically determine the size of the ${type} file. Please specify a length in bytes to carve from the start offset (0x${startOffset.toString(16)}).`, 1024 * 1024 * 2); // Default 2MB
                if (userInput === null) return;
                const length = parseInt(userInput);
                if (isNaN(length) || length <= 0) { alert('Invalid length provided.'); return; }
                endOffset = startOffset + length;
            }

            if (endOffset > file.size) endOffset = file.size;

            const carvedSize = endOffset - startOffset;
            const blob = file.slice(startOffset, endOffset);
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `carved_${type.split(' ')[0]}_at_0x${startOffset.toString(16)}.${sigInfo.ext}`;
            document.body.appendChild(a); a.click(); document.body.removeChild(a);
            URL.revokeObjectURL(url);

            addCoCEntry('File Carved', a.download, 'high', `Carved ${type} file of size ${(carvedSize/1024).toFixed(2)} KB from ${file.name} at offset 0x${startOffset.toString(16)}.`);
            alert(`Successfully carved ${a.download} (${(carvedSize/1024).toFixed(2)} KB).`);
        }

        function renderHexView(bytes) {
            const viewer = document.getElementById('hex-viewer-output');
            if (!viewer) return;

            let html = '';
            const bytesLength = bytes.length;

            for (let i = 0; i < bytesLength; i += 16) {
                const slice = bytes.slice(i, i + 16);
                
                // 1. Offset
                const offset = i.toString(16).padStart(8, '0');
                html += `<div class="row"><span class="hex-offset">${offset}</span>`;

                // 2. Hex Bytes
                let hexString = '';
                for (let j = 0; j < 16; j++) {
                    if (j < slice.length) {
                        hexString += `<span class="hex-byte">${slice[j].toString(16).padStart(2, '0')}</span>`;
                    } else {
                        hexString += '<span class="hex-byte">  </span>'; // Padding for shorter last line
                    }
                    if (j === 7) hexString += ' '; // Space in the middle
                }
                html += hexString;

                // 3. ASCII representation
                let asciiString = ' <span class="hex-ascii">';
                for (let j = 0; j < slice.length; j++) {
                    const charCode = slice[j];
                    const char = (charCode >= 32 && charCode <= 126) ? String.fromCharCode(charCode) : '.';
                    asciiString += char.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                }
                asciiString += '</span>';
                html += asciiString;

                html += '</div>';
            }
            viewer.innerHTML = html || '<span>File is empty or could not be read.</span>';
        }

        async function compareFiles() {
            const fileInput1 = document.getElementById('file-compare-1');
            const fileInput2 = document.getElementById('file-compare-2');
            const output = document.getElementById('comparison-output');
            const progressBar = document.querySelector('#comparison-card .progress-bar-inner');
            progressBar.style.width = '0%';

            if (!fileInput1.files[0] || !fileInput2.files[0]) {
                output.innerHTML = '<span class="danger">Please select two files to compare.</span>';
                return;
            }

            const file1 = fileInput1.files[0];
            const file2 = fileInput2.files[0];
            addCoCEntry('File Comparison', `${file1.name} vs ${file2.name}`, 'medium', 'Initiated file comparison.', 'auto');

            // --- Streaming Comparison for Large Files ---
            const chunkSize = 1024 * 1024; // 1MB chunks

            // Hashers for file 1
            const sha256Hasher1 = CryptoJS.algo.SHA256.create();
            const sha1Hasher1 = CryptoJS.algo.SHA1.create();
            const md5Hasher1 = CryptoJS.algo.MD5.create();

            // Hashers for file 2
            const sha256Hasher2 = CryptoJS.algo.SHA256.create();
            const sha1Hasher2 = CryptoJS.algo.SHA1.create();
            const md5Hasher2 = CryptoJS.algo.MD5.create();

            let totalBytesProcessed = 0;
            const totalSizeToProcess = Math.max(file1.size, file2.size);

            // Prepare for diff map
            const canvas = document.getElementById('diff-map-canvas');
            const width = canvas.width;
            const height = canvas.height;
            const numDiffBlocks = width * height;
            const diffBlocks = new Array(numDiffBlocks).fill(false);
            const bytesPerBlock = Math.max(1, Math.floor(totalSizeToProcess / numDiffBlocks));

            // Read first 256 bytes for hex diff view
            const firstBytes1 = new Uint8Array(await file1.slice(0, 256).arrayBuffer());
            const firstBytes2 = new Uint8Array(await file2.slice(0, 256).arrayBuffer());

            for (let offset = 0; offset < totalSizeToProcess; offset += chunkSize) {
                const [chunkBuffer1, chunkBuffer2] = await Promise.all([
                    file1.slice(offset, offset + chunkSize).arrayBuffer(),
                    file2.slice(offset, offset + chunkSize).arrayBuffer()
                ]);

                const chunkBytes1 = new Uint8Array(chunkBuffer1);
                const chunkBytes2 = new Uint8Array(chunkBuffer2);

                // Update hashes
                sha256Hasher1.update(CryptoJS.lib.WordArray.create(chunkBytes1));
                sha1Hasher1.update(CryptoJS.lib.WordArray.create(chunkBytes1));
                md5Hasher1.update(CryptoJS.lib.WordArray.create(chunkBytes1));

                sha256Hasher2.update(CryptoJS.lib.WordArray.create(chunkBytes2));
                sha1Hasher2.update(CryptoJS.lib.WordArray.create(chunkBytes2));
                md5Hasher2.update(CryptoJS.lib.WordArray.create(chunkBytes2));

                // Compare chunks and update diff map data
                const maxChunkLen = Math.max(chunkBytes1.length, chunkBytes2.length);
                for (let i = 0; i < maxChunkLen; i++) {
                    const currentOffset = offset + i;
                    if (chunkBytes1[i] !== chunkBytes2[i]) {
                        const blockIndex = Math.floor(currentOffset / bytesPerBlock);
                        if (blockIndex < numDiffBlocks) {
                            diffBlocks[blockIndex] = true;
                        }
                    }
                }

                totalBytesProcessed += chunkSize;
                progressBar.style.width = `${(Math.min(totalBytesProcessed, totalSizeToProcess) / totalSizeToProcess) * 100}%`;
            }

            progressBar.style.width = '100%';

            // Finalize hashes
            const hashes1 = {
                md5: md5Hasher1.finalize().toString(),
                sha1: sha1Hasher1.finalize().toString(),
                sha256: sha256Hasher1.finalize().toString()
            };
            const hashes2 = {
                md5: md5Hasher2.finalize().toString(),
                sha1: sha1Hasher2.finalize().toString(),
                sha256: sha256Hasher2.finalize().toString()
            };

            const sameSHA256 = hashes1.sha256 === hashes2.sha256;
            let resultHTML = '';

            if (sameSHA256) {
                resultHTML = `<div class="comparison-summary summary-identical"><i class="fas fa-check-circle"></i> Files are cryptographically identical.</div>`;
            } else {
                resultHTML = `<div class="comparison-summary summary-different"><i class="fas fa-times-circle"></i> Files are different.</div>`;
            }

            resultHTML += `
                <table class="comparison-results-table">
                    <thead>
                        <tr><th colspan="2" class="file-header">File 1: ${sanitizeHTML(file1.name)} (${(file1.size / 1024).toFixed(2)} KB)</th></tr>
                    </thead>
                    <tbody>
                        <tr><th>MD5</th><td>${hashes1.md5}</td></tr>
                        <tr><th>SHA-1</th><td>${hashes1.sha1}</td></tr>
                        <tr><th>SHA-256</th><td>${hashes1.sha256}</td></tr>
                    </tbody>
                </table>
                <table class="comparison-results-table">
                     <thead>
                        <tr><th colspan="2" class="file-header">File 2: ${sanitizeHTML(file2.name)} (${(file2.size / 1024).toFixed(2)} KB)</th></tr>
                    </thead>
                    <tbody>
                        <tr><th>MD5</th><td>${hashes2.md5}</td></tr>
                        <tr><th>SHA-1</th><td>${hashes2.sha1}</td></tr>
                        <tr><th>SHA-256</th><td>${hashes2.sha256}</td></tr>
                    </tbody>
                </table>
            `;

            if (!sameSHA256) {
                resultHTML += `<div class="interpretation">The visual 'Diff Map' below shows where the files differ. Red areas indicate changed blocks.</div>`;
            }
            
            output.innerHTML = resultHTML;
            analysisResults.comparison = { file1: { name: file1.name, size: file1.size, hashes: hashes1 }, file2: { name: file2.name, size: file2.size, hashes: hashes2 }, areIdentical: sameSHA256, firstBytes1, firstBytes2 };
            if (sameSHA256) {
                addCoCEntry('Comparison Result', `${file1.name} vs ${file2.name}`, 'low', 'Files are identical.', 'auto');
            } else {
                addCoCEntry('Comparison Result', `${file1.name} vs ${file2.name}`, 'high', 'Files are different.', 'auto');
            }
            renderDiffMap(diffBlocks, width, height);
        }

        function renderDiffMap(diffBlocks, width, height) {
            const canvas = document.getElementById('diff-map-canvas');
            canvas.style.display = 'block';
            const ctx = canvas.getContext('2d');
            
            const blockWidth = canvas.width / width;
            const blockHeight = canvas.height / height;
            
            const diffColor = getComputedStyle(document.body).getPropertyValue('--diff-color').trim();
            const sameColor = 'rgba(63, 131, 248, 0.1)';

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            for (let i = 0; i < diffBlocks.length; i++) {
                const x = (i % width) * blockWidth;
                const y = Math.floor(i / width) * blockHeight;
                
                ctx.fillStyle = diffBlocks[i] ? diffColor : sameColor;
                ctx.fillRect(x, y, blockWidth, blockHeight);
            }
        }

        async function analyzeMetadata() {
            const fileInput = document.getElementById('photo-upload');
            const output = document.getElementById('metadata-output');
            const aiBtn = document.getElementById('meta-ai-btn');
            aiBtn.style.display = 'none'; 

            if (!fileInput.files[0]) {
                output.innerHTML = '<span class="danger">Please select a file.</span>';
                return;
            }
            const file = fileInput.files[0];
            addCoCEntry('Metadata Analysis', file.name, 'low', 'Initiated metadata extraction.', 'auto');

            try {
                const tags = await ExifReader.load(file, { expanded: true });

                if (Object.keys(tags).length === 0 || (Object.keys(tags).length === 1 && tags.file)) {
                    output.innerHTML = `<span class="warning">No significant EXIF/metadata found for ${sanitizeHTML(file.name)}.</span>`;
                    addCoCEntry('Metadata Analysis', file.name, 'medium', `No metadata tags found.`, 'auto');
                    return;
                }

                let allEntries = [];
                let keyFindings = {};
                let groupedTags = {}; // To build the full report

                // Single pass to process all tags
                for (const groupName in tags) {
                    if (!tags[groupName] || typeof tags[groupName] !== 'object' || groupName === 'thumbnail') continue;
                    
                    groupedTags[groupName] = {};

                    for (const tagName in tags[groupName]) {
                        const tag = tags[groupName][tagName];
                        if (tag && typeof tag.description !== 'undefined') {
                            const value = tag.description;
                            allEntries.push({ group: groupName, key: tagName, value });
                            groupedTags[groupName][tagName] = value;

                            // Populate key findings
                            const lowerKey = tagName.toLowerCase();
                            if (lowerKey.includes('datetimeoriginal')) keyFindings['Timestamp'] = value;
                            if (lowerKey.includes('software')) keyFindings['Software'] = value;
                            if (lowerKey.includes('make') || lowerKey.includes('model')) keyFindings['Device'] = `${keyFindings['Device'] || ''} ${value}`.trim();
                            if (lowerKey.includes('serialnumber')) keyFindings['Device Serial'] = value;
                            if (lowerKey.includes('author') || lowerKey.includes('creator')) keyFindings['Author'] = value;
                        }
                    }
                }

                const mapContainer = document.getElementById('map-container');
                // Defensive check for valid, numeric GPS coordinates before attempting to render the map.
                if (tags.gps && tags.gps.Latitude && typeof tags.gps.Latitude.description === 'number' && tags.gps.Longitude && typeof tags.gps.Longitude.description === 'number') {
                    mapContainer.style.display = 'block';
                    const lat = tags.gps.Latitude.description;
                    const lon = tags.gps.Longitude.description;
                    keyFindings['GPS'] = `${lat}, ${lon}`;
                    renderMap(lat, lon);
                } else {
                    mapContainer.style.display = 'none';
                    if (mapInstance) { mapInstance.remove(); mapInstance = null; }
                }

                let keyFindingsHTML = '<div class="key-findings-box"><h3>Key Forensic Findings</h3>';
                if (Object.keys(keyFindings).length > 0) {
                    for(const key in keyFindings) {
                        const safeValue = sanitizeHTML(String(keyFindings[key]));
                        keyFindingsHTML += `<div class="key-finding-item"><span class="key">${key}</span><span class="value">${safeValue}</span></div>`;
                    }
                } else {
                     keyFindingsHTML += `<div class="key-finding-item"><span class="key">No common forensic artifacts identified.</span></div>`;
                }
                keyFindingsHTML += '</div>';

                let fullReportHTML = '<details><summary>View Full Metadata Report</summary><div style="padding-left: 1rem; margin-top: 0.5rem;">';
                for (const groupName in groupedTags) {
                    const groupHeader = `--- ${groupName.charAt(0).toUpperCase() + groupName.slice(1)} ---`;
                    let groupContent = '';
                    for (const tagName in groupedTags[groupName]) {
                        const value = groupedTags[groupName][tagName];
                        if (tagName.toLowerCase() === 'padding' || (typeof value === 'string' && value.length > 200)) {
                            groupContent += `${tagName.padEnd(30)}: [Large data block hidden]\n`;
                        } else {
                            groupContent += `${tagName.padEnd(30)}: ${sanitizeHTML(String(value))}\n`;
                        }
                    }
                    if (groupContent) {
                        fullReportHTML += `<details><summary>${groupHeader}</summary><pre style="margin-top: 0.5rem; white-space: pre-wrap;">${groupContent}</pre></details>`;
                    }
                }
                fullReportHTML += '</div></details>';
                
                output.innerHTML = keyFindingsHTML + fullReportHTML;
                analysisResults.metadata = { fileName: file.name, data: allEntries, totalTags: allEntries.length, keyFindings };
                addCoCEntry('Metadata Extracted', file.name, 'low', `Extracted ${allEntries.length} total tags.`, 'auto');
                aiBtn.style.display = 'flex';

            } catch (error) {
                console.error("Metadata analysis error:", error);
                output.innerHTML = `<span class="danger">Error analyzing metadata: ${sanitizeHTML(error.message)}.</span>`;
                addCoCEntry('Metadata Error', file.name, 'medium', `Error: ${error.message}`, 'auto');
            }
        }

        function renderMap(lat, lon) {
            const container = document.getElementById('map-container');
            if (mapInstance) {
                mapInstance.remove();
                mapInstance = null;
            }
            mapInstance = L.map(container).setView([lat, lon], 13);
            
            // Initial theme setup for the map
            updateMapTheme();

            L.marker([lat, lon]).addTo(mapInstance).bindPopup('Location from metadata.').openPopup();
        }

        // --- NEW: Map Theme Toggling ---
        function updateMapTheme() {
            if (!mapInstance) return;

            // Remove the old tile layer if it exists
            if (mapInstance.tileLayer) {
                mapInstance.removeLayer(mapInstance.tileLayer);
            }

            const isLightTheme = document.body.classList.contains('light-theme');
            const tileUrl = isLightTheme 
                ? 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png' 
                : 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png';
            const attribution = isLightTheme
                ? '&copy; OpenStreetMap contributors'
                : '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>';

            const newTileLayer = L.tileLayer(tileUrl, {
                maxZoom: 19,
                attribution: attribution
            }).addTo(mapInstance);

            // Store a reference to the current tile layer so it can be removed later
            mapInstance.tileLayer = newTileLayer;
        }

        async function getMetadataAIInsights() {
            if (!analysisResults.metadata || !analysisResults.metadata.keyFindings) {
                alert("Please analyze a file first.");
                return;
            }

            const aiBtn = document.getElementById('meta-ai-btn');
            aiBtn.disabled = true;
            aiBtn.innerHTML = `<div class="loading-spinner" style="width: 1em; height: 1em; border-width: 2px;"></div>`;

            const prompt = `As a digital forensics expert, provide a concise narrative about the potential history and significance of a file based on these key metadata findings. What can you infer? What are the next logical steps for an investigator? Be direct and clear. \n\nKey Findings:\n${JSON.stringify(analysisResults.metadata.keyFindings, null, 2)}`;
            
            const aiResponse = await callGemini(prompt);
            const output = document.getElementById('metadata-output');
            const interpretationDiv = document.createElement('div');
            interpretationDiv.className = 'interpretation';
            interpretationDiv.innerHTML = `<strong>✨ AI Insights:</strong><br>${sanitizeHTML(aiResponse).replace(/\n/g, '<br>')}`;
            output.appendChild(interpretationDiv);

            aiBtn.disabled = false;
            aiBtn.innerHTML = `✨ Get AI Insights`;
        }

        async function analyzeSteganography() {
            const fileInput = document.getElementById('steg-file');
            const output = document.getElementById('steg-output');
            const previewCanvas = document.getElementById('steg-preview-canvas');
            
            if (!fileInput.files[0]) {
                output.innerHTML = '<span class="danger">Please select an image.</span>';
                return;
            }
            const file = fileInput.files[0];
            const channel = parseInt(document.getElementById('steg-channel').value);
            const bitPlane = parseInt(document.getElementById('steg-bit-plane').value);

            addCoCEntry('Stego Analysis', file.name, 'medium', `Initiated bit plane ${bitPlane} analysis on channel ${['R','G','B','A'][channel]}.`, 'auto');

            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d', { willReadFrequently: true });
                    ctx.drawImage(img, 0, 0);
                    
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    const bitPlaneData = new Uint8ClampedArray(data.length);
                    let extractedBits = [];
                    const bitMask = 1 << bitPlane;

                    for (let i = 0; i < data.length; i += 4) {
                        const bit = (data[i + channel] & bitMask) > 0 ? 255 : 0;
                        extractedBits.push(bit === 255 ? 1 : 0);
                        bitPlaneData[i] = bit; bitPlaneData[i + 1] = bit; bitPlaneData[i + 2] = bit; bitPlaneData[i + 3] = 255;
                    }
                    
                    previewCanvas.width = img.width;
                    previewCanvas.height = img.height;
                    const previewCtx = previewCanvas.getContext('2d');
                    previewCtx.putImageData(new ImageData(bitPlaneData, img.width, img.height), 0, 0);
                    previewCanvas.style.display = 'block';

                    const entropy = calculateEntropy(new Uint8Array(extractedBits));
                    const isSuspicious = entropy > 0.9;

                    let resultText = `--- Bit Plane Analysis Report: ${sanitizeHTML(file.name)} ---\n\n`;
                    resultText += `Image Dimensions: ${img.width}x${img.height}\n`;
                    resultText += `Analyzed Channel: ${['Red', 'Green', 'Blue', 'Alpha'][channel]}\n`;
                    resultText += `Analyzed Bit Plane: ${bitPlane} (${bitPlane === 0 ? 'LSB' : bitPlane === 7 ? 'MSB' : ''})\n`;
                    resultText += `Bit Plane Entropy: ${entropy.toFixed(4)} / 1.0\n\n`;
                    
                    if (isSuspicious) {
                        resultText += `<span class="danger">HIGH ENTROPY DETECTED</span>\n`;
                        resultText += `<div class="interpretation"><strong>Interpretation:</strong> The entropy of this bit plane is abnormally high, suggesting it does not contain uniform image data. This is a strong indicator of embedded data. Visually inspect the bit plane image above for non-random patterns.</div>`;
                    } else {
                        resultText += `<span class="success">No evidence of high-entropy data found.</span>\n`;
                        resultText += `<div class="interpretation"><strong>Interpretation:</strong> The entropy is low, which is consistent with natural image data. Hidden data may still exist, but it is not random-looking.</div>`;
                    }
                    
                    output.innerHTML = resultText;
                    analysisResults.steganography = { fileName: file.name, method: `Bit Plane ${bitPlane} (${['R','G','B','A'][channel]})`, riskLevel: isSuspicious ? 'High' : 'Low', entropy: entropy.toFixed(4), found: isSuspicious };
                    addCoCEntry('Stego Scan Complete', file.name, isSuspicious ? 'high' : 'low', `${isSuspicious ? 'Suspicious data detected' : 'No obvious payload'}.`, 'auto');
                }
                img.onerror = () => { output.innerHTML = `<span class="danger">Could not load the selected file as an image.</span>`; }
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }
        
        function updatePasswordStrengthBarVisuals() {
            const password = document.getElementById('password-input').value;
            const scoreData = calculatePasswordScore(password);
            renderPasswordStrengthBar(scoreData);
        }

        async function analyzePassword() {
            const password = document.getElementById('password-input').value;
            const output = document.getElementById('password-output');
            
            if (!password) {
                output.innerHTML = '<span class="danger">Please enter a password.</span>';
                const scoreData = calculatePasswordScore('');
                renderPasswordStrengthBar(scoreData);
                return;
            }
            
            addCoCEntry('Password Analysis', '********', 'medium', 'Initiated strength analysis.', 'auto');
            
            const scoreData = calculatePasswordScore(password);
            const entropy = scoreData.entropy;
            const timeToCrack = formatTime((Math.pow(2, entropy) / 1e11) * 0.5); // 100 Giga-hashes/sec
            
            renderPasswordStrengthBar(scoreData);

            let resultHTML = `
                <div class="password-audit-grid">
                    <div class="audit-metric">
                        <span class="label">Password Entropy</span>
                        <span class="value info">${entropy.toFixed(2)} bits</span>
                    </div>
                    <div class="audit-metric">
                        <span class="label">Est. Crack Time</span>
                        <span class="value ${entropy < 60 ? 'danger' : 'success'}">${timeToCrack}</span>
                    </div>
                </div>
            `;
            
            if (scoreData.suggestions.length > 0) {
                resultHTML += `<div class="password-recommendations"><h4>Recommendations</h4><ul>`;
                scoreData.suggestions.forEach(sug => resultHTML += `<li>${sug}</li>`);
                resultHTML += `</ul></div>`;
            } else {
                resultHTML += `<div class="password-recommendations"><h4>Recommendations</h4><ul><li class="good-practice">This is a strong password. No immediate recommendations.</li></ul></div>`;
            }
            output.innerHTML = resultHTML;
            
            analysisResults.password = { timeToCrack, strength: scoreData.strengthText, entropyBits: entropy.toFixed(2), suggestions: scoreData.suggestions };
            addCoCEntry('Password Scan Complete', '********', entropy > 80 ? 'low' : (entropy > 60 ? 'medium' : 'high'), `Entropy: ${entropy.toFixed(2)} bits.`, 'auto');
        }

        function calculatePasswordScore(password) {
            let suggestions = [];
            const len = password.length;

            const checks = {
                length: len >= 12,
                uppercase: /[A-Z]/.test(password),
                lowercase: /[a-z]/.test(password),
                number: /\d/.test(password),
                symbol: /[^a-zA-Z\d]/.test(password)
            };

            let pool = 0;
            if (checks.lowercase) pool += 26;
            if (checks.uppercase) pool += 26;
            if (checks.number) pool += 10;
            if (checks.symbol) pool += 32;
            
            if (!checks.length) suggestions.push(`Increase length to at least 12 characters (currently ${len}).`);
            if (!checks.uppercase) suggestions.push("Add uppercase letters.");
            if (!checks.lowercase) suggestions.push("Add lowercase letters.");
            if (!checks.number) suggestions.push("Add numbers.");
            if (!checks.symbol) suggestions.push("Add symbols (e.g., !@#$).");

            const entropy = len * Math.log2(pool || 1);

            let score = 0;
            let strengthText = "Very Weak";
            if (entropy >= 100) { score = 100; strengthText = "Very Strong"; }
            else if (entropy >= 80) { score = 80; strengthText = "Strong"; }
            else if (entropy >= 60) { score = 60; strengthText = "Moderate"; }
            else if (entropy >= 40) { score = 40; strengthText = "Weak"; }
            else if (entropy > 0) { score = 20; strengthText = "Very Weak"; }
            
            return { score, suggestions, entropy, strengthText, checks };
        }

        function renderPasswordStrengthBar(scoreData) {
            const bar = document.getElementById('strength-bar-main');
            const text = document.getElementById('strength-text');
            
            let color = 'var(--danger)';
            if (scoreData.score >= 80) color = 'var(--success)';
            else if (scoreData.score >= 60) color = 'var(--warning)';

            bar.style.width = `${scoreData.score}%`;
            bar.style.backgroundColor = color;
            text.textContent = scoreData.strengthText;
            text.style.color = color;
        }

        // This function is no longer used and can be removed.
        // function logPasswordAnalysis() { ... }

        function formatTime(seconds) {
            if (seconds < 1e-6) return "instantly";
            if (seconds < 60) return `${seconds.toPrecision(2)} seconds`;
            if (seconds < 3600) return `${(seconds / 60).toPrecision(2)} minutes`;
            if (seconds < 86400) return `${(seconds / 3600).toPrecision(2)} hours`;
            if (seconds < 31536000) return `${(seconds / 86400).toPrecision(2)} days`;
            const years = seconds / 31536000;
            if (years > 1e12) return "trillions of years";
            if (years > 1e9) return `${(years / 1e9).toPrecision(3)} billion years`;
            if (years > 1e6) return `${(years / 1e6).toPrecision(3)} million years`;
            if (years > 1000) return `${(years / 1000).toPrecision(3)} thousand years`;
            return `${years.toPrecision(3)} years`;
        }

        // --- ADVANCED NETWORK LOG ANALYZER ---
        async function analyzeNetworkAdvanced() {
            const input = document.getElementById('network-input').value;
            const watchlistInput = document.getElementById('ip-watchlist').value;
            const output = document.getElementById('network-output');
            const aiBtn = document.getElementById('net-ai-btn');
            aiBtn.style.display = 'none';

            if (!input) {
                output.innerHTML = '<span class="danger">Please paste log data.</span>'; return;
            }
            addCoCEntry('Advanced Log Analysis', 'Pasted Data', 'medium', 'Initiated contextual threat analysis.', 'auto');

            // Parse the IP watchlist into a Set for efficient lookups
            const watchlistIPs = new Set(watchlistInput
                .split(/[\s,;\n]+/)
                .map(ip => ip.trim())
                .filter(ip => ip.length > 0)
            );

            const lines = input.split('\n').filter(line => line.trim() !== '');
            
            const sqlInjectionPattern = new RegExp('(union|select|insert|update|delete|drop|--|#|/\\*)', 'i');
            const ipRegex = /(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/; // Generic IP regex for watchlist check

            const patterns = {
                'Failed Login': { pattern: /failed password for(?: invalid user)? (\S+)/i, score: 1, type: 'auth_fail', extracts: { user: 1, ip: /from (\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/ } },
                'Successful Login': { pattern: /accepted password for (\S+)/i, score: 0, type: 'auth_success', extracts: { user: 1, ip: /from (\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/ } },
                'SSH Login': { pattern: /accepted publickey for (\S+)/i, score: 0, type: 'auth_success', extracts: { user: 1, ip: /from (\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/ } },
                'Sudo Command': { pattern: /sudo: \s*(\S+)\s*: TTY=.* PWD=.* USER=root COMMAND=(.*)/i, score: 3, type: 'priv_esc', extracts: { user: 1, command: 2 } },
                'SQL Injection Attempt': { pattern: sqlInjectionPattern, score: 10, type: 'web_attack' },
                'Directory Traversal': { pattern: /(\.\.\/|\.\.\\|etc\/passwd)/i, score: 10, type: 'web_attack' },
                'Suspicious User Agent': { pattern: /" (curl|wget|python|nmap|sqlmap|masscan)/i, score: 4, type: 'recon' },
                'Web Error': { pattern: /" (404|403|500) \d+/i, score: 1, type: 'web_error' }
            };

            let events = [];
            lines.forEach((line, index) => {
                for (const [name, p] of Object.entries(patterns)) {
                    const match = line.match(p.pattern);
                    if (match) {
                        let details = { name, line: index + 1, score: p.score, type: p.type, content: line };
                        if (p.extracts) {
                            for (const [key, extractor] of Object.entries(p.extracts)) {
                                if (typeof extractor === 'number') {
                                    details[key] = match[extractor];
                                } else {
                                    const detailMatch = line.match(extractor);
                                    if (detailMatch) details[key] = detailMatch[1];
                                }
                            }
                        }
                        events.push(details);
                        break; // Only match first pattern per line
                    }
                }
            });

            let threats = [];
            const loginFails = events.filter(e => e.type === 'auth_fail');
            const failsByIp = loginFails.reduce((acc, e) => {
                if (e.ip) {
                    acc[e.ip] = (acc[e.ip] || 0) + 1;
                }
                return acc;
            }, {});

            for (const [ip, count] of Object.entries(failsByIp)) {
                if (count >= 5) {
                    const successAfter = events.find(e => e.type === 'auth_success' && e.ip === ip && e.line > loginFails.find(f => f.ip === ip).line);
                    const risk = successAfter ? 'CRITICAL' : 'High';
                    const score = successAfter ? 25 : 15;
                    threats.push({
                        name: `Brute-Force Attack${successAfter ? ' (Successful)' : ''}`,
                        risk, score,
                        details: `Detected ${count} failed login attempts from IP ${ip}, ${successAfter ? 'followed by a successful login.' : 'potentially ongoing.'}`
                    });
                }
            }
            
            const successLogins = events.filter(e => e.type === 'auth_success');
            for (const login of successLogins) {
                const subsequentCommands = events.filter(e => e.type === 'priv_esc' && e.user === login.user && e.line > login.line);
                if (subsequentCommands.length > 0) {
                    threats.push({
                        name: 'Suspicious Post-Login Activity',
                        risk: 'High', score: 20,
                        details: `User '${login.user}' logged in from ${login.ip || 'unknown IP'} and then executed ${subsequentCommands.length} privileged command(s), starting with: ${subsequentCommands[0].command}`
                    });
                }
            }

            events.filter(e => e.score >= 10).forEach(e => {
                threats.push({ name: e.name, risk: 'High', score: e.score, details: `Detected on line ${e.line}: ${e.content.substring(0, 100)}...` });
            });

            // Add threats for any IPs found on the watchlist
            if (watchlistIPs.size > 0) {
                const processedLines = new Set(); // Avoid duplicate alerts for the same line
                lines.forEach((line, index) => {
                    const ipMatch = line.match(ipRegex);
                    if (ipMatch && watchlistIPs.has(ipMatch[0]) && !processedLines.has(index)) {
                        const matchedIp = ipMatch[0];
                        threats.push({
                            name: 'IP Watchlist Hit',
                            risk: 'CRITICAL',
                            score: 25,
                            details: `IP address ${matchedIp} from the watchlist was detected on line ${index + 1}: ${line.substring(0, 100)}...`
                        });
                        addCoCEntry('IP Watchlist Hit', matchedIp, 'high', `IP found on line ${index + 1}.`, 'auto');
                        processedLines.add(index);
                    }
                });
            }

            // Sort threats by risk level to show most critical first
            const riskOrder = { 'CRITICAL': 0, 'High': 1, 'Medium': 2, 'Low': 3 };
            threats.sort((a, b) => (riskOrder[a.risk] || 99) - (riskOrder[b.risk] || 99));

            const totalScore = threats.reduce((sum, t) => sum + t.score, 0);
            let threatLevel, threatColor;
            if (totalScore >= 25) { threatLevel = 'CRITICAL'; threatColor = 'danger'; }
            else if (totalScore >= 15) { threatLevel = 'HIGH'; threatColor = 'danger'; }
            else if (totalScore >= 5) { threatLevel = 'MEDIUM'; threatColor = 'warning'; }
            else if (totalScore > 0) { threatLevel = 'LOW'; threatColor = 'info'; }
            else { threatLevel = 'Minimal'; threatColor = 'success'; }

            let resultHTML = `
                <div class="network-summary">
                    <div>
                        <span>Overall Threat Score</span>
                        <span class="${threatColor}" style="font-size: 1.2em; font-weight: bold;">${totalScore}</span>
                    </div>
                    <div>
                        <span>Assessed Threat Level</span>
                        <span class="${threatColor}" style="font-size: 1.2em; font-weight: bold;">${threatLevel}</span>
                    </div>
                </div>
            `;

            if (threats.length > 0) {
                resultHTML += `<h4>Correlated Threats Detected</h4>
                    <table class="threat-table">
                        <thead><tr><th>Risk</th><th>Threat</th><th>Details</th></tr></thead>
                        <tbody>`;
                threats.forEach(t => {
                    const riskColor = t.risk === 'CRITICAL' || t.risk === 'High' ? 'danger' : 'warning';
                    resultHTML += `
                        <tr>
                            <td><span class="${riskColor}">[${t.risk}]</span></td>
                            <td><strong>${t.name}</strong><br><small>(Score: ${t.score})</small></td>
                            <td class="threat-details-cell">${sanitizeHTML(t.details)}</td>
                        </tr>
                    `;
                });
                resultHTML += '</tbody></table>';
                aiBtn.style.display = 'flex';
            } else {
                resultHTML += `<p class="success" style="margin-top: 1rem;">No significant correlated threats detected.</p>`;
            }

            output.innerHTML = resultHTML;
            const riskDistribution = threats.reduce((acc, t) => {
                const risk = t.risk.toUpperCase();
                acc[risk] = (acc[risk] || 0) + 1;
                return acc;
            }, {});

            analysisResults.network = { risk: threatLevel, threats, score: totalScore, lines: lines.length, riskDistribution, allEvents: events };
            addCoCEntry('Advanced Log Scan Complete', `${lines.length} lines`, threatLevel.toLowerCase(), `Threat score: ${totalScore}. Found ${threats.length} correlated threats.`, 'auto');
        }


        async function getNetworkAIInsights() {
            if (!analysisResults.network || !analysisResults.network.threats || analysisResults.network.threats.length === 0) {
                alert("Please run an advanced analysis that detects threats first.");
                return;
            }

            const aiBtn = document.getElementById('net-ai-btn');
            aiBtn.disabled = true;
            aiBtn.innerHTML = `<div class="loading-spinner" style="width: 1em; height: 1em; border-width: 2px;"></div>`;

            const threatsForPrompt = analysisResults.network.threats.map(t => `- ${t.name} (Risk: ${t.risk}): ${t.details}`).join('\n');
            const prompt = `As a senior cybersecurity analyst, my advanced log analysis engine detected the following correlated threats. Please provide a concise, expert explanation of what these findings mean collectively. What is the likely attack scenario? What are the immediate, actionable recommendations for a forensic investigator? Be direct and clear.\n\nDetected Threats:\n${threatsForPrompt}`;
            
            const aiResponse = await callGemini(prompt);

            const output = document.getElementById('network-output');
            const interpretationDiv = document.createElement('div');
            interpretationDiv.className = 'interpretation';
            interpretationDiv.innerHTML = `<strong>✨ AI Explanation:</strong><br>${sanitizeHTML(aiResponse).replace(/\n/g, '<br>')}`;
            output.appendChild(interpretationDiv);

            aiBtn.disabled = false;
            aiBtn.innerHTML = `✨ Explain Threats with AI`;
        }


        // --- PROFESSIONAL PDF REPORTING ENGINE (ENHANCED v7.4) ---
        async function exportToPDF() {
            // --- NEW: Validation for required fields ---
            const caseNameInput = document.getElementById('case-name');
            const investigatorNameInput = document.getElementById('investigator-name');
            
            let requiredFields = [caseNameInput, investigatorNameInput];
            let missingFields = false;

            requiredFields.forEach(input => {
                if (!input.value.trim()) {
                    input.style.borderColor = 'var(--danger)';
                    missingFields = true;
                } else {
                    input.style.borderColor = ''; // Reset if filled
                }
            });

            if (missingFields) {
                alert('Please fill in all required fields (Case Name, Investigator Name) before generating a report.');
                return;
            }
            try {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF({ orientation: 'p', unit: 'mm', format: 'a4' });

                const caseInfo = {
                    caseName: document.getElementById('case-name').value || "Unnamed Case",
                    investigatorName: document.getElementById('investigator-name').value || "N/A",
                    orgName: document.getElementById('org-name').value || "N/A",
                    caseType: document.getElementById('case-type').value || "N/A",
                    isCourtMode: document.getElementById('court-mode').checked,
                    version: "N.I.T.T.A.L.A. v8.0",
                    sessionId: analysisResults.sessionId
                };

                // NEW: PDFReportBuilder class encapsulates all PDF creation logic.
                class PDFReportBuilder {
                    constructor(doc, caseInfo) {
                        this.doc = doc;
                        this.caseInfo = caseInfo;
                        this.yPos = 0;
                        this.margin = 20;
                        this.pageWidth = doc.internal.pageSize.getWidth();
                        this.pageHeight = doc.internal.pageSize.getHeight();
                        this.sectionCounter = { main: 1, sub: 1 };
                        this.toc = [];
                    }

                    // --- Core PDF Building Blocks ---
                    addPage() {
                        this.doc.addPage();
                        this.yPos = this.margin;
                        this.addHeaders();
                    }
                    
                    addHeaders() {
                        const pageNum = this.doc.internal.getNumberOfPages();
                        this.doc.setPage(pageNum);
                        this.doc.setFont('helvetica', 'normal').setFontSize(9).setTextColor(80, 80, 80);
                        this.doc.text(`Digital Forensic Report | Case: ${this.caseInfo.caseName}`, this.margin, 12);
                        this.doc.text(`Page ${pageNum}`, this.pageWidth - this.margin, 12, { align: 'right' });
                        this.doc.setDrawColor(220).line(this.margin, 15, this.pageWidth - this.margin, 15);
                        this.doc.setFont('helvetica', 'normal').setFontSize(8).setTextColor(80, 80, 80);
                        this.doc.text(`Report by ${this.caseInfo.investigatorName}`, this.margin, this.pageHeight - 10);
                        this.doc.text(`Generated by ${this.caseInfo.version}`, this.pageWidth - this.margin, this.pageHeight - 10, { align: 'right' });
                    }
                    
                    addWatermark() {
                        const pageCount = this.doc.internal.getNumberOfPages();
                        for (let i = 1; i <= pageCount; i++) {
                            this.doc.setPage(i);
                            this.doc.saveGraphicsState();
                            this.doc.setGState(new this.doc.GState({opacity: 0.08}));
                            this.doc.setFont('helvetica', 'bold');
                            this.doc.setFontSize(this.caseInfo.isCourtMode ? 80 : 100);
                            this.doc.setTextColor(0, 0, 0);
                            const watermarkText = this.caseInfo.isCourtMode ? "FOR COURT USE ONLY" : "N.I.T.T.A.L.A";
                            this.doc.text(watermarkText, this.pageWidth / 2, this.pageHeight / 1.8, { angle: -45, align: 'center' });
                            this.doc.restoreGraphicsState();
                        }
                    }

                    checkPageBreak(elementHeight) {
                        if (this.yPos + elementHeight > this.pageHeight - (this.margin + 5)) {
                            this.addPage();
                        }
                    }

                    addTitle(title, level = 1, toc = true) {
                        const fontSize = level === 1 ? 18 : (level === 2 ? 14 : 11);
                        const elementHeight = (fontSize * 0.7) + (level === 1 ? 8 : (level === 2 ? 6 : 4));
                        let fullTitle = title;
                        if (level === 1) {
                            fullTitle = `${this.sectionCounter.main}.0 ${title}`;
                            this.sectionCounter.main++;
                            this.sectionCounter.sub = 1;
                        } else if (level === 2) {
                            fullTitle = `${this.sectionCounter.main - 1}.${this.sectionCounter.sub} ${title}`;
                            this.sectionCounter.sub++;
                        }

                        this.checkPageBreak(elementHeight);
                        this.doc.setFont('helvetica', 'bold').setFontSize(fontSize).setTextColor(30, 50, 100);
                        this.doc.text(fullTitle, this.margin, this.yPos);
                        if(toc) this.toc.push({ title: fullTitle, page: this.doc.internal.getNumberOfPages(), y: this.yPos, level });
                        this.yPos += elementHeight;
                    }

                    addSectionHeader(title) {
                        const fullTitle = `${this.sectionCounter.main}.0 ${title}`;
                        this.sectionCounter.main++;
                        this.sectionCounter.sub = 1;
                        this.checkPageBreak(20);
                        this.doc.setFillColor(30, 50, 100);
                        this.doc.rect(this.margin, this.yPos - 10, this.pageWidth - (this.margin * 2), 12, 'F');
                        this.doc.setFont('helvetica', 'bold').setFontSize(16).setTextColor(255, 255, 255);
                        this.doc.text(fullTitle, this.margin + 3, this.yPos);
                        this.toc.push({ title: fullTitle, page: this.doc.internal.getNumberOfPages(), y: this.yPos, level: 1 });
                        this.yPos += 10;
                    }

                    addText(text) {
                        const splitText = this.doc.splitTextToSize(text, this.pageWidth - this.margin * 2);
                        const textHeight = this.doc.getTextDimensions(splitText).h + 5;
                        this.checkPageBreak(textHeight);
                        this.doc.setFont('helvetica', 'normal').setFontSize(11).setTextColor(0,0,0);
                        this.doc.text(splitText, this.margin, this.yPos, { lineHeightFactor: 1.5 });
                        this.yPos += textHeight;
                    }

                    addTable(head, body, columnStyles = {}) {
                        const tableHeight = (body.length + 1) * 10 + 10;
                        this.checkPageBreak(tableHeight);
                        this.doc.autoTable({
                            startY: this.yPos,
                            head: [head],
                            body: body,
                            theme: 'grid',
                            headStyles: { fillColor: [30, 50, 100] },
                            styles: { cellPadding: 2, fontSize: 9 },
                            columnStyles: columnStyles
                        });
                        this.yPos = this.doc.autoTable.previous.finalY + 10;
                    }
                    
                    // --- Report Section Builders ---

                    addCoverPage() {
                        this.yPos = 60;
                        this.doc.setFont('helvetica', 'bold').setFontSize(26).setTextColor(30, 50, 100).text("Digital Forensic Examination Report", this.pageWidth / 2, this.yPos, { align: 'center' });
                        this.yPos += 10;
                        this.doc.setFont('helvetica', 'normal').setFontSize(14).setTextColor(80, 80, 80).text(this.caseInfo.version, this.pageWidth / 2, this.yPos, { align: 'center' });
                        this.yPos += 25;
                        this.doc.autoTable({
                            startY: this.yPos, theme: 'plain', styles: { font: 'helvetica', fontSize: 11, cellPadding: 5 },
                            body: [
                                [{content: 'Case ID / Name:', styles:{fontStyle:'bold', cellWidth: 50}}, this.caseInfo.caseName],
                                [{content: 'Case Type:', styles:{fontStyle:'bold', cellWidth: 50}}, this.caseInfo.caseType],
                                [{content: 'Organization:', styles:{fontStyle:'bold', cellWidth: 50}}, this.caseInfo.orgName],
                                [{content: 'Lead Investigator:', styles:{fontStyle:'bold', cellWidth: 50}}, this.caseInfo.investigatorName],
                                [{content: 'Report Date:', styles:{fontStyle:'bold', cellWidth: 50}}, new Date().toUTCString()],
                            ]
                        });
                    }

                    addTableOfContents() {
                        this.addPage();
                        this.addSectionHeader("Table of Contents");

                        this.toc.forEach(item => {
                            this.checkPageBreak(8);
                            this.doc.setFont('helvetica', 'normal').setFontSize(11);
                            const indent = (item.level - 1) * 8;
                            const titleWidth = this.doc.getTextWidth(item.title);
                            const pageNumWidth = this.doc.getTextWidth(item.page.toString());
                            const availableWidth = this.pageWidth - (this.margin * 2) - indent - titleWidth - pageNumWidth - 4;

                            // Draw link first
                            if (item.level === 1) {
                                this.doc.setFont('helvetica', 'bold').setTextColor(30, 50, 100);
                            } else {
                                this.doc.setFont('helvetica', 'normal').setTextColor(0, 0, 200);
                            }
                            this.doc.textWithLink(item.title, this.margin + indent, this.yPos, { pageNumber: item.page, y: item.y });

                            // Draw dot leaders
                            this.doc.setTextColor(150, 150, 150);
                            if (availableWidth > 0) {
                                const dots = '.'.repeat(Math.floor(availableWidth / this.doc.getTextWidth('.')));
                                this.doc.text(dots, this.margin + indent + titleWidth + 2, this.yPos, { align: 'left' });
                            }

                            // Draw page number
                            this.doc.setTextColor(0, 0, 0);
                            this.doc.text(`${item.page}`, this.pageWidth - this.margin, this.yPos, { align: 'right' });
                            this.yPos += 8;
                        });
                    }

                    addExecutiveSummary() {
                        this.addPage();
                        this.addSectionHeader("Executive Summary");
                        let summaryText = `This report details the forensic findings for Case: ${this.caseInfo.caseName}. The examination was conducted using the ${this.caseInfo.version} toolkit.\n\n`;
                        if (aiSummaryForReport) summaryText += `AI-Generated Summary:\n"${aiSummaryForReport}"\n\n`;
                        
                        const findings = Object.keys(analysisResults).filter(k => k !== 'sessionId');
                        if (findings.length === 0) {
                            summaryText += "No analyses were performed in this session.";
                        } else {
                            summaryText += "The following analyses were performed in this session:\n";
                            findings.forEach(finding => {
                                const findingName = finding.charAt(0).toUpperCase() + finding.slice(1).replace(/([A-Z])/g, ' $1').trim();
                                summaryText += `• ${findingName} Analysis\n`;
                            });
                        }
                        this.addText(summaryText);
                    }
                    
                    addDetailedFindings() {
                        this.addPage();
                        this.addSectionHeader("Detailed Forensic Findings");
                        if (Object.keys(analysisResults).length <= 1) {
                            this.addText("No analysis results to report.");
                            return;
                        }
                        if (analysisResults.fileHash) this.addFileIntegritySection();
                        if (analysisResults.comparison) this.addComparisonSection();
                        if (analysisResults.metadata) this.addMetadataSection();
                        if (analysisResults.steganography) this.addStegoSection();
                        if (analysisResults.password) this.addPasswordSection();
                        if (analysisResults.network) this.addNetworkSection();
                    }

                    addFileIntegritySection() {
                        this.addTitle("File Integrity & Threat Scan", 2);
                        const res = analysisResults.fileHash;
                        this.addTable(['Property', 'Value'], [
                            ['Filename', res.fileName],
                            ['File Size', `${res.fileSize.toLocaleString()} bytes`],
                            ['Identified Type', res.fileType],
                            ['MD5 Hash', res.hashes.md5],
                            ['SHA-1 Hash', res.hashes.sha1],
                            ['SHA-256 Hash', res.hashes.sha256],
                            ['Shannon Entropy (Overall)', res.entropy.toFixed(4)],
                            ['Entropy Assessment', res.entropyAssessment || 'N/A'],
                            ['Threat Status', res.isMalicious ? `THREAT: ${res.threatName}` : 'Clean']
                        ], { 0: { cellWidth: 50 }, 1: { styles: { font: 'courier' } } });
                        
                        if (res.blockEntropy) {
                            this.addTable(['Block Entropy Metric', 'Value'], [
                                ['Minimum Block Entropy', res.blockEntropy.min.toFixed(4)],
                                ['Maximum Block Entropy', res.blockEntropy.max.toFixed(4)],
                                ['Average Block Entropy', res.blockEntropy.average.toFixed(4)],
                            ], { 0: { cellWidth: 50 } });
                        }
                        
                        const freqChartCanvas = document.getElementById('entropy-chart');
                        if (freqChartCanvas && freqChartCanvas.style.display !== 'none') {
                            try {
                                const chartImage = freqChartCanvas.toDataURL('image/png');
                                this.addTitle("Byte Frequency Chart", 3, false);
                                this.checkPageBreak(70);
                                this.doc.addImage(chartImage, 'PNG', (this.pageWidth - 120) / 2, this.yPos, 120, 60);
                                this.yPos += 70;
                                this.doc.setFont('helvetica', 'italic').setFontSize(9).setTextColor(80, 80, 80).text("Figure: Distribution of byte values from 0x00 to 0xFF.", this.pageWidth / 2, this.yPos, { align: 'center' });
                                this.yPos += 5;
                            } catch (e) { console.error("Could not add entropy chart to PDF", e); }
                        }

                        const plotChartCanvas = document.getElementById('byte-plot-chart');
                        if (plotChartCanvas && plotChartCanvas.style.display !== 'none') {
                            try {
                                const chartImage = plotChartCanvas.toDataURL('image/png');
                                this.addTitle("File Entropy Plot", 3, false);
                                this.checkPageBreak(85);
                                this.doc.addImage(chartImage, 'PNG', (this.pageWidth - 160) / 2, this.yPos, 160, 70);
                                this.yPos += 80;
                                this.doc.setFont('helvetica', 'italic').setFontSize(9).setTextColor(80, 80, 80).text("Figure: Shannon entropy calculated over sequential blocks of the file.", this.pageWidth / 2, this.yPos, { align: 'center' });
                                this.yPos += 5;
                            } catch (e) { console.error("Could not add entropy plot chart to PDF", e); }
                        }
                    }

                    addComparisonSection() {
                        this.addTitle("File Comparison Analysis", 2);
                        const res = analysisResults.comparison;
                        if (!res) return;

                        this.addTable(['Property', 'File 1: ' + res.file1.name, 'File 2: ' + res.file2.name], [
                            ['File Size', `${res.file1.size.toLocaleString()} bytes`, `${res.file2.size.toLocaleString()} bytes`],
                            ['MD5', res.file1.hashes.md5, res.file2.hashes.md5],
                            ['SHA-1', res.file1.hashes.sha1, res.file2.hashes.sha1],
                            ['SHA-256', res.file1.hashes.sha256, res.file2.hashes.sha256],
                        ], { 1: { styles: { font: 'courier' } }, 2: { styles: { font: 'courier' } } });

                        if (res.areIdentical) {
                            this.addText("Conclusion: The files are cryptographically identical.");
                        } else {
                            this.addText("Conclusion: The files are different.");
                            
                            const diffMapCanvas = document.getElementById('diff-map-canvas');
                            if (diffMapCanvas && diffMapCanvas.style.display !== 'none') {
                                try {
                                    const chartImage = diffMapCanvas.toDataURL('image/png');
                                    this.addTitle("File Difference Map", 3, false);
                                    this.checkPageBreak(40);
                                    this.doc.addImage(chartImage, 'PNG', (this.pageWidth - 170) / 2, this.yPos, 170, 30);
                                    this.yPos += 40;
                                    this.doc.setFont('helvetica', 'italic').setFontSize(9).setTextColor(80, 80, 80).text("Figure: A visual map of the file differences. Red areas indicate changed blocks.", this.pageWidth / 2, this.yPos, { align: 'center' });
                                    this.yPos += 10;
                                } catch (e) { console.error("Could not add diff map to PDF", e); }
                            }

                            this.addTitle("Hex Difference View (First 256 Bytes)", 3, false);
                            this.addHexDiffToPdf(res.firstBytes1, res.firstBytes2, 256);
                        }
                    }

                    addHexDiffToPdf(bytes1, bytes2, limit) {
                        const len = Math.min(limit, Math.max(bytes1.length, bytes2.length));
                        this.doc.setFont('courier', 'normal').setFontSize(8);
                        this.checkPageBreak(10);

                        for (let i = 0; i < len; i += 16) {
                            this.checkPageBreak(8); // Check for each pair of rows
                            let ascii1 = '', ascii2 = '';
                            let coloredSegments1 = [], coloredSegments2 = [];

                            for (let j = 0; j < 16; j++) {
                                const offset = i + j;
                                const byte1 = offset < bytes1.length ? bytes1[offset] : null;
                                const byte2 = offset < bytes2.length ? bytes2[offset] : null;
                                const diff = byte1 !== byte2;

                                if (byte1 !== null) { coloredSegments1.push({ text: byte1.toString(16).padStart(2, '0') + ' ', color: diff ? 'red' : 'black' }); ascii1 += byte1 >= 32 && byte1 <= 126 ? String.fromCharCode(byte1) : '.'; } else { coloredSegments1.push({ text: '   ', color: 'black' }); ascii1 += ' '; }
                                if (byte2 !== null) { coloredSegments2.push({ text: byte2.toString(16).padStart(2, '0') + ' ', color: diff ? 'red' : 'black' }); ascii2 += byte2 >= 32 && byte2 <= 126 ? String.fromCharCode(byte2) : '.'; } else { coloredSegments2.push({ text: '   ', color: 'black' }); ascii2 += ' '; }
                            }

                            const offsetHex = i.toString(16).padStart(8, '0');
                            this.doc.setTextColor(80, 80, 80).text(offsetHex, this.margin, this.yPos);
                            
                            let xPos = this.margin + 25;
                            coloredSegments1.forEach(seg => { this.doc.setTextColor(seg.color === 'red' ? 239 : 0, seg.color === 'red' ? 68 : 0, seg.color === 'red' ? 68 : 0); this.doc.text(seg.text, xPos, this.yPos); xPos += this.doc.getTextWidth(seg.text); });
                            this.doc.setTextColor(0,0,0).text(ascii1, xPos + 5, this.yPos); this.yPos += 4;

                            xPos = this.margin + 25;
                            coloredSegments2.forEach(seg => { this.doc.setTextColor(seg.color === 'red' ? 239 : 0, seg.color === 'red' ? 68 : 0, seg.color === 'red' ? 68 : 0); this.doc.text(seg.text, xPos, this.yPos); xPos += this.doc.getTextWidth(seg.text); });
                            this.doc.setTextColor(0,0,0).text(ascii2, xPos + 5, this.yPos); this.yPos += 6;
                        }
                    }

                    addMetadataSection() {
                        this.addTitle("Metadata Analysis", 2);
                        const res = analysisResults.metadata;
                        if (Object.keys(res.keyFindings).length > 0) {
                            this.addTitle("Key Findings", 3, false);
                            const findingsBody = Object.entries(res.keyFindings);
                            if (document.getElementById('map-container').style.display !== 'none') { findingsBody.push(['Note', 'GPS coordinates were visualized on an interactive map within the tool.']); }
                            this.addTable(['Key Finding', 'Value'], findingsBody, { 0: { cellWidth: 40 } });
                        }
                        this.addTitle("All Extracted Metadata", 3, false);
                        const allMetaBody = res.data.map(d => [d.group, d.key, d.value]);
                        this.addTable(['Group', 'Tag', 'Value'], allMetaBody, { 0: { cellWidth: 30 }, 1: { cellWidth: 40 } });
                    }
                    
                    addStegoSection() {
                        this.addTitle("Steganography Analysis", 2);
                        const res = analysisResults.steganography;
                        this.addTable(['Property', 'Value'], [
                            ['Filename', res.fileName],
                            ['Analysis Method', res.method],
                            ['LSB Alpha Entropy', res.entropy],
                            ['Result', res.found ? 'High probability of hidden data' : 'No evidence found']
                        ], { 0: { cellWidth: 50 } });

                        const chartCanvas = document.getElementById('steg-preview-canvas');
                        if (chartCanvas && chartCanvas.style.display !== 'none') {
                            try {
                                const chartImage = chartCanvas.toDataURL('image/png');
                                this.addTitle("Bit Plane Visualization", 3, false);
                                this.checkPageBreak(85);
                                this.doc.text("The following image represents the extracted bit plane (white=1, black=0):", this.margin, this.yPos);
                                this.yPos += 8;
                                this.doc.addImage(chartImage, 'PNG', (this.pageWidth - 90) / 2, this.yPos, 90, 70, undefined, 'FAST');
                                this.yPos += 80;
                                this.doc.setFont('helvetica', 'italic').setFontSize(9).setTextColor(80, 80, 80).text("Figure: Visual representation of the selected bit plane.", this.pageWidth / 2, this.yPos, { align: 'center' });
                                this.yPos += 5;
                            } catch (e) { console.error("Could not add stego chart to PDF", e); }
                        }
                    }
                    
                    addPasswordSection() {
                        this.addTitle("Password Audit", 2);
                        const res = analysisResults.password;
                        this.addTable(['Metric', 'Result'], [
                            ['Strength', res.strength],
                            ['Entropy', `${res.entropyBits} bits`],
                            ['Estimated Crack Time', res.timeToCrack],
                            ['Recommendations', res.suggestions.join('\n')]
                        ], { 0: { cellWidth: 50 } });
                    }
                    
                    async addNetworkSection() {
                        this.addTitle("Network Log Analysis", 2);
                        const res = analysisResults.network;
                        this.addTable(['Metric', 'Value'], [
                            ['Lines Analyzed', res.lines],
                            ['Overall Threat Score', res.score],
                            ['Assessed Threat Level', res.risk],
                            ['Correlated Threats Found', res.threats.length],
                        ], { 0: { cellWidth: 50 } });
                        
                        if (res.threats.length > 0) {
                            this.addTitle("Correlated Threats", 3, false);
                            const threatsBody = res.threats.map(t => [t.risk, t.name, t.details]);
                            this.addTable(['Risk', 'Threat Name', 'Details'], threatsBody, { 0: { cellWidth: 25 }, 1: { cellWidth: 45 } });
                        }

                        if (res.allEvents && res.allEvents.length > 0) {
                            this.addTitle("All Detected Events Log", 3, false);
                            const eventsBody = res.allEvents.map(e => [e.line, e.name, e.type, e.score]);
                            this.addTable(['Line #', 'Event Name', 'Type', 'Score'], eventsBody, { 0: { cellWidth: 20 }, 3: { cellWidth: 20 } });
                        }
                    }

                    addCaseNotesSection() {
                        const notes = document.getElementById('case-notes-textarea').value;
                        if (notes && notes.trim() !== '') {
                            this.addPage();
                            this.addTitle("Investigator's Case Notes");
                            this.addText(notes);
                        }
                    }

                    addChainOfCustodySection() {
                        this.addPage();
                        this.addTitle("Chain of Custody Log");
                        this.addText("Each entry is cryptographically linked to the previous one, ensuring the integrity of the log. Any modification to an entry will invalidate the entire chain that follows.");

                        if (chainOfCustody.length === 0) {
                            this.addText("No chain of custody events were recorded for this session.");
                            return;
                        }

                        const cocBody = chainOfCustody.map(entry => [
                            entry.timestamp,
                            entry.action,
                            entry.target,
                            entry.hash.substring(0, 16) + '...'
                        ]);

                        this.addTable(['Timestamp', 'Action', 'Target', 'Entry Hash (SHA-256)'], cocBody, { 0: { cellWidth: 35 }, 3: { styles: { font: 'courier', fontSize: 7 }, cellWidth: 40 } });
                        const finalHash = chainOfCustody[0].hash;
                        this.addTitle("Final Chain Integrity Hash", 3, false);
                        this.addText(`The hash of the final entry, which validates the entire chain, is:\n${finalHash}`);
                    }

                    addAttestationSection() {
                        this.addPage();
                        this.addTitle("Investigator's Attestation");
                        const attestText = "I, the undersigned, attest that the information contained within this report is accurate to the best of my knowledge and that all procedures were conducted in a forensically sound manner.";
                        this.addText(attestText);
                        this.yPos += 30;
                        this.doc.setDrawColor(100).line(this.margin, this.yPos, this.margin + 80, this.yPos);
                        this.yPos += 5;
                        this.doc.text(`Signature: ${this.caseInfo.investigatorName}`, this.margin, this.yPos);
                    }
                    
                    async build() {
                        // --- Build Document ---
                        this.addCoverPage();
                        
                        // --- Build Content Pages ---
                        this.addExecutiveSummary();
                        this.addDetailedFindings();
                        this.addCaseNotesSection();
                        this.addChainOfCustodySection();
                        this.addAttestationSection();
                        
                        // --- Finalize: Build TOC, Watermark, and Headers ---
                        const totalPages = this.doc.internal.getNumberOfPages();
                        this.addTableOfContents();
                        this.addWatermark();

                        // Re-add headers to all pages to ensure they are on top of the watermark
                        for (let i = 1; i <= totalPages + 1; i++) {
                            this.doc.setPage(i);
                            this.addHeaders();
                        }
                    }
                }

                const builder = new PDFReportBuilder(doc, caseInfo);
                await builder.build();

                doc.setProperties({
                    title: `Forensic Report: ${caseInfo.caseName}`,
                    subject: `Digital evidence analysis for case ${caseInfo.caseName}`,
                    author: caseInfo.investigatorName,
                    keywords: `forensic, report, ${caseInfo.caseType}, ${caseInfo.sessionId}`,
                    creator: caseInfo.version
                });

                addCoCEntry('Report Exported', `${caseInfo.caseName}.pdf`, 'low', `PDF report generated.`, 'auto');
                doc.save(`NITTALA-Report-${caseInfo.caseName}.pdf`);
            
            } catch (e) {
                console.error("PDF Generation Error:", e);
                alert("Failed to generate PDF. Check console for details.");
            }
        }
        
        function addCoCEntry(action, target, status, details, type = 'auto') {
            // Get the hash of the last entry (which is the first element since we unshift)
            const previousHash = chainOfCustody.length > 0 ? chainOfCustody[0].hash : '0'.repeat(64);
            const now = new Date();

            const entryData = {
                id: now.getTime(),
                action, 
                target, 
                status, 
                type,
                details: `${details} (Session: ${analysisResults.sessionId})`, 
                timestamp: now.toLocaleString('en-US', { dateStyle: 'short', timeStyle: 'medium' }),
                previousHash: previousHash
            };

            // Create a consistent string representation of the entry to hash
            const entryString = `${entryData.id}|${entryData.action}|${entryData.target}|${entryData.status}|${entryData.type}|${entryData.details}|${entryData.timestamp}|${entryData.previousHash}`;
            const currentHash = CryptoJS.SHA256(entryString).toString();

            const finalEntry = { ...entryData, hash: currentHash };

            chainOfCustody.unshift(finalEntry);
            if (chainOfCustody.length > 100) chainOfCustody.pop();
            renderCoC();
        }

        function renderCoC() {
            const container = document.getElementById('coc-log');
            if (!container) return;
            container.innerHTML = '';
            if (chainOfCustody.length === 0) {
                container.innerHTML = '<p style="font-size: 0.9rem; color: var(--text-secondary); padding-left: 0;">Log is empty. Start an analysis to populate.</p>';
                return;
            }
            chainOfCustody.forEach(entry => {
                const el = document.createElement('div');
                el.className = 'coc-entry';
                el.onclick = () => showCoCDetails(entry.id);
                el.innerHTML = `
                    <span class="coc-status status-${entry.status}"></span>
                    <div class="coc-info">
                        <span class="coc-action">${entry.action}</span>
                        <span class="coc-meta">${entry.timestamp}</span>
                        <span class="coc-target">Target: ${entry.target}</span>
                    </div>`;
                container.appendChild(el);
            });
        }
        
        function showCoCDetails(id) {
            const entry = chainOfCustody.find(e => e.id === id);
            if (!entry) return;
            document.getElementById('modal-title').textContent = `${entry.action} Details`;
            const detailsText = `Action:    ${entry.action}\nTarget:    ${entry.target}\nStatus:    ${entry.status ? entry.status.toUpperCase() : 'N/A'}\nTimestamp: ${entry.timestamp}\n\nDetails:\n${entry.details}\n\n--- Cryptographic Integrity ---\nPrevious Entry Hash: ${entry.previousHash}\nCurrent Entry Hash:  ${entry.hash}`;
            document.getElementById('modal-body').textContent = detailsText;

            const copyBtn = document.getElementById('copy-coc-btn');
            copyBtn.onclick = () => copyToClipboard(detailsText, copyBtn);

            // Add onclick for the new verify button
            const verifyBtn = document.getElementById('verify-coc-btn');
            verifyBtn.onclick = () => verifyChainOfCustody(true);

            document.getElementById('coc-modal').classList.add('active');
        }
        
        function closeModal() { document.getElementById('coc-modal').classList.remove('active'); }
        function closeTimelineModal() { document.getElementById('timeline-modal').classList.remove('active'); }
        function closeAddCocModal() { document.getElementById('add-coc-modal').classList.remove('active'); }
        function openAddCocModal() { document.getElementById('add-coc-modal').classList.add('active'); }

        function getIconForAction(entry) {
            if (entry.type === 'manual') return 'fa-pencil-alt';

            const lowerAction = entry.action.toLowerCase();
            if (lowerAction.includes('scan') || lowerAction.includes('analysis') || lowerAction.includes('analyze')) return 'fa-search';
            if (lowerAction.includes('acquired') || lowerAction.includes('loaded')) return 'fa-upload';
            if (lowerAction.includes('exported') || lowerAction.includes('saved')) return 'fa-save';
            if (lowerAction.includes('started')) return 'fa-play-circle';
            if (lowerAction.includes('extracted') || lowerAction.includes('metadata')) return 'fa-tags';
            if (lowerAction.includes('comparison')) return 'fa-exchange-alt';
            if (lowerAction.includes('password')) return 'fa-key';
            if (lowerAction.includes('stego')) return 'fa-eye-slash';
            return 'fa-info-circle';
        }

        function renderTimeline() {
            const container = document.getElementById('timeline-body');
            if (!container || chainOfCustody.length === 0) {
                container.innerHTML = '<p>No events in the Chain of Custody log yet.</p>';
                return;
            }

            // The CoC is stored with newest first, so we reverse for a chronological timeline
            const chronologicalCoC = [...chainOfCustody].reverse(); 

            let timelineHTML = '<div class="timeline-container">';

            chronologicalCoC.forEach(entry => {
                const iconClass = getIconForAction(entry);
                timelineHTML += `
                    <div class="timeline-item">
                        <div class="timeline-dot status-${entry.status}">
                            <i class="fas ${iconClass}"></i>
                        </div>
                        <div class="timeline-content" onclick="showCoCDetails(${entry.id})">
                            <h4>${entry.action}</h4>
                            <div class="time">${entry.timestamp}</div>
                            <p><strong>Target:</strong> ${entry.target}</p>
                        </div>
                    </div>`;
            });

            timelineHTML += '</div>';
            container.innerHTML = timelineHTML;
        }

        function openTimelineModal() {
            renderTimeline();
            document.getElementById('timeline-modal').classList.add('active');
        }

        function submitManualCoCEntry() {
            const action = document.getElementById('coc-manual-action').value.trim();
            const target = document.getElementById('coc-manual-target').value.trim();
            const status = document.getElementById('coc-manual-status').value;
            const details = document.getElementById('coc-manual-details').value.trim();

            if (!action || !target) {
                alert("Please fill in at least the Action and Target fields.");
                return;
            }

            addCoCEntry(action, target, status, details || 'Manual entry.', 'manual');

            // Clear the form and close the modal
            document.getElementById('coc-manual-action').value = '';
            document.getElementById('coc-manual-target').value = '';
            document.getElementById('coc-manual-details').value = '';
            document.getElementById('coc-manual-status').value = 'medium';
            closeAddCocModal();
        }

        // --- BACKGROUND CONSTELLATION & CURSOR ANIMATION ---
        if (localStorage.getItem('animationsDisabled') !== 'true') {
            const bgCanvas = document.getElementById('background-canvas');
            let isAnimationPaused = false;
            if (bgCanvas) {
                const ctx = bgCanvas.getContext('2d');
                let particles = [];
                let particleCount = window.innerWidth > 768 ? 100 : 35;
                const maxDistance = 120;
                let constellationColorRgb;
                let lineOpacity = 1;

                // --- Matrix Rain State ---
                let rainDrops = [];
                const rainCount = 100;
                const rainChars = '01'; // Binary rain
                const rainFontSize = 14;

                class RainDrop {
                    constructor(x, y, speed, text) {
                        this.x = x; this.y = y; this.speed = speed; this.text = text;
                    }
                    draw() {
                        ctx.fillStyle = `rgba(${constellationColorRgb}, 0.5)`;
                        ctx.font = `${rainFontSize}px "Roboto Mono"`;
                        ctx.fillText(this.text, this.x, this.y);
                        this.y += this.speed;
                        if (this.y > bgCanvas.height) {
                            this.y = 0;
                            this.x = Math.random() * bgCanvas.width;
                            this.speed = Math.random() * 2 + 1;
                        }
                    }
                }

                // --- Cursor Trail State ---
                const mouse = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
                const trailParticles = [];
                const numTrailParticles = 40; // Number of particles in the trail
                const trailLag = 0.2; // Lower is more "springy" and smoother

                const toolIcons = [
                    '\ue06c', // fa-shield-virus
                    '\uf362', // fa-exchange-alt
                    '\uf083', // fa-camera-retro
                    '\uf070', // fa-eye-slash
                    '\uf084', // fa-key
                    '\uf6ff'  // fa-network-wired
                ];

                function getTrailColors() {
                    return [
                        getComputedStyle(document.documentElement).getPropertyValue('--trail-color-1').trim(),
                        getComputedStyle(document.documentElement).getPropertyValue('--trail-color-2').trim(),
                        getComputedStyle(document.documentElement).getPropertyValue('--trail-color-3').trim()
                    ];
                }
                for (let i = 0; i < numTrailParticles; i++) {
                    trailParticles.push({
                        x: mouse.x, y: mouse.y, 
                        color: 'white', // Placeholder color
                        shape: toolIcons[i % toolIcons.length]
                    });
                }
                
                window.addEventListener('mousemove', (e) => {
                    mouse.x = e.clientX;
                    mouse.y = e.clientY;
                });
                
                // --- NEW: Add touch support for cursor trail on mobile ---
                window.addEventListener('touchmove', (e) => {
                    if (e.touches.length > 0) {
                        mouse.x = e.touches[0].clientX;
                        mouse.y = e.touches[0].clientY;
                    }
                }, { passive: true }); // Use passive for better scroll performance

                window.addEventListener('touchstart', (e) => {
                    if (e.touches.length > 0) {
                        mouse.x = e.touches[0].clientX;
                        mouse.y = e.touches[0].clientY;
                    }
                }, { passive: true });

                window.addEventListener('mouseout', () => {
                    // Optional: could make the trail converge to center or just stop
                });

                function updateConstellationColors() {
                    const colorString = getComputedStyle(document.body).getPropertyValue('--constellation-color-rgb').trim();
                    constellationColorRgb = colorString || '63, 131, 248'; // Fallback
                    // Update trail colors if theme changes
                    const colors = getTrailColors();
                    for (let i = 0; i < numTrailParticles; i++) {
                        if (trailParticles[i]) trailParticles[i].color = colors[i % colors.length];
                    }
                }

                function resizeCanvas() {
                    bgCanvas.width = window.innerWidth;
                    bgCanvas.height = window.innerHeight;
                    particleCount = window.innerWidth > 768 ? 100 : 35;
                }

                class Particle {
                    constructor() {
                        this.x = Math.random() * bgCanvas.width;
                        this.y = Math.random() * bgCanvas.height;
                        this.vx = (Math.random() - 0.5) * 0.6;
                        this.vy = (Math.random() - 0.5) * 0.6;
                        this.baseRadius = Math.random() * 1.5 + 1;
                        this.radius = this.baseRadius;
                        this.pulseSpeed = (Math.random() * 0.001) + 0.0005;
                        this.pulseOffset = Math.random() * Math.PI * 2;
                    }
                    update() {
                        this.x += this.vx;
                        this.y += this.vy;
                        if (this.x < 0 || this.x > bgCanvas.width) this.vx *= -1;
                        if (this.y < 0 || this.y > bgCanvas.height) this.vy *= -1;
                        // Pulsing logic for the radius
                        this.radius = this.baseRadius + Math.sin(Date.now() * this.pulseSpeed + this.pulseOffset) * 1.0;
                    }
                    draw() {
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(${constellationColorRgb}, 1.0)`; // Increased brightness
                        ctx.fill();
                    }
                }

                function initMatrixRain() {
                    rainDrops = [];
                    for (let i = 0; i < rainCount; i++) {
                        rainDrops.push(new RainDrop(
                            Math.random() * bgCanvas.width,
                            Math.random() * bgCanvas.height,
                            Math.random() * 2 + 1,
                            rainChars[Math.floor(Math.random() * rainChars.length)]
                        ));
                    }
                }

                function initConstellation() {
                    resizeCanvas();
                    updateConstellationColors();
                    particles = [];
                    for (let i = 0; i < particleCount; i++) {
                        particles.push(new Particle());
                    }
                    initMatrixRain();
                }

                function connectParticles() {
                    for (let i = 0; i < particles.length; i++) {
                        for (let j = i + 1; j < particles.length; j++) {
                            const dx = particles[i].x - particles[j].x;
                            const dy = particles[i].y - particles[j].y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            if (distance < maxDistance) {
                                ctx.beginPath();
                                ctx.moveTo(particles[i].x, particles[i].y);
                                ctx.lineTo(particles[j].x, particles[j].y);
                                const baseOpacity = 1 - distance / maxDistance;
                                ctx.strokeStyle = `rgba(${constellationColorRgb}, ${baseOpacity * lineOpacity})`;
                                ctx.lineWidth = 0.5;
                                ctx.stroke();
                            }
                        }
                    }
                }

                function drawCursorTrail() {
                    // The first particle follows the mouse
                    let leader = trailParticles[0];
                    leader.x += (mouse.x - leader.x) * trailLag;
                    leader.y += (mouse.y - leader.y) * trailLag;

                    // Other particles follow the one in front of them
                    for (let i = 1; i < trailParticles.length; i++) {
                        const follower = trailParticles[i];
                        const leader = trailParticles[i - 1];
                        follower.x += (leader.x - follower.x) * trailLag;
                        follower.y += (leader.y - follower.y) * trailLag;
                    }

                    // Draw the particles, from tail to head for correct layering
                    for (let i = trailParticles.length - 1; i >= 0; i--) {
                        const p = trailParticles[i];
                        // t is normalized position in trail, 1 at head, 0 at tail
                        const t = (trailParticles.length - 1 - i) / (trailParticles.length - 1);
                        const size = t * 18 + 8; // Size decreases from 26px at head to 8px at tail
                        const opacity = t * 0.9; // Opacity fades out towards the tail
                        const rgb = hexToRgb(p.color);
                        if (rgb) {
                            // Instead of drawing a circle, we draw the icon shape
                            ctx.font = `900 ${size}px "Font Awesome 6 Free"`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
                            ctx.fillText(p.shape, p.x, p.y);
                        }
                    }
                }

                function drawMatrixRain() {
                    rainDrops.forEach(drop => drop.draw());
                }

                function animateConstellation() {
                    if (isAnimationPaused) {
                        requestAnimationFrame(animateConstellation);
                        return; // Skip drawing if tab is not visible
                    }

                    ctx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
                    
                    // Update global line opacity for a gentle fading effect
                    lineOpacity = (Math.sin(Date.now() * 0.0005) + 1) / 2 * 0.7 + 0.3; // Oscillates between 0.3 and 1.0
                    
                    // Draw Matrix rain behind constellation
                    drawMatrixRain();

                    // Draw constellation first
                    particles.forEach(p => { p.update(); p.draw(); });
                    connectParticles();

                    // Draw cursor trail on top
                    drawCursorTrail();

                    requestAnimationFrame(animateConstellation);
                }

                window.addEventListener('resize', initConstellation);
                initConstellation();
                animateConstellation();
            }
        }
    </script>

    <style>
    /* --- Detailed Info Section --- */
    .detailed-info-section {
        background-color: var(--secondary-bg);
        border-top: 1px solid var(--border-color);
        padding: 4rem 1rem;
        margin-top: 3rem;
    }
    .detailed-info-wrapper {
        max-width: 1000px;
        margin: 0 auto;
    }
    .detailed-info-section h2 {
        font-size: 2.25rem;
        font-weight: 700;
        text-align: center;
        margin-bottom: 1rem;
        color: var(--text-primary);
    }
    .detailed-info-section .intro-paragraph {
        font-size: 1.125rem;
        color: var(--text-secondary);
        text-align: center;
        max-width: 800px;
        margin: 0 auto 3rem auto;
    }
    .detailed-info-section h3 {
        font-size: 1.5rem;
        font-weight: 600;
        color: var(--accent-primary);
        margin-bottom: 1rem;
        padding-bottom: 0.5rem;
        border-bottom: 1px solid var(--border-color);
    }
    .detailed-info-section .mission-text {
        font-size: 1rem;
        color: var(--text-secondary);
        line-height: 1.7;
        margin-bottom: 2.5rem;
    }
    .feature-list {
        list-style: none;
        padding: 0;
    }
    .feature-list li {
        display: flex;
        gap: 1.5rem;
        align-items: flex-start;
        margin-bottom: 2rem;
    }
    .feature-list i {
        font-size: 1.75rem;
        color: var(--accent-secondary);
        margin-top: 0.25rem;
        width: 30px;
        text-align: center;
    }
    .feature-list h4 {
        font-size: 1.2rem;
        font-weight: 600;
        color: var(--text-primary);
        margin-bottom: 0.25rem;
    }
    .feature-list p {
        margin-bottom: 0;
        font-size: 0.95rem;
        color: var(--text-secondary);
        line-height: 1.6;
    }
    .support-email-link {
        color: var(--accent-primary);
        text-decoration: none;
        font-weight: 600;
        transition: color 0.2s;
    }
    .support-email-link:hover {
        color: var(--accent-secondary);
        text-decoration: underline;
    }
    .support-email-link i {
        margin-right: 0.5rem;
    }
    </style>
    <section class="detailed-info-section">
        <div class="detailed-info-wrapper">
            <h2>About N.I.T.T.A.L.A.</h2>
            <p class="intro-paragraph">A closer look at the mission, features, and design philosophy behind this forensic suite.</p>
            
            <h3>Our Mission</h3>
            <p class="mission-text">N.I.T.T.A.L.A. was born from a simple yet powerful idea: to democratize digital forensics. We believe that powerful analysis tools should be accessible, secure, and transparent. Our core philosophy is built on <strong>client-side processing</strong>, meaning every calculation, every analysis, and every byte of your sensitive data remains exclusively on your computer. There are no server uploads, no hidden data collection, and no complex installations required. This approach not only guarantees absolute privacy but also makes sophisticated forensic techniques available to anyone with a web browser, from students learning the trade to professionals in the field conducting initial assessments.</p>

            <h3>Privacy by Design</h3>
            <p class="mission-text">Your privacy is not an afterthought; it is the foundation of this suite. Here is our commitment to you:</p>
            <ul class="feature-list" style="margin-top: 1.5rem;">
                <li><i class="fas fa-server"></i><div><h4>Zero Data Transmission</h4><p>All files you select and data you paste are processed locally within your browser. Nothing is ever sent to, or stored on, any external server. Your evidence remains your own.</p></div></li>
                <li><i class="fas fa-cookie-bite"></i><div><h4>No Tracking Cookies</h4><p>This tool does not use tracking cookies or third-party analytics that monitor your behavior. Settings are stored in your browser's `localStorage`, which you control and can clear at any time.</p></div></li>
                <li><i class="fas fa-code"></i><div><h4>Open and Verifiable</h4><p>As a single-file HTML application, the entire source code is visible and can be audited by anyone. You can save the page and run it offline to verify its client-side nature.</p></div></li>
            </ul>

            <h3>Support & Contact</h3>
            <p class="mission-text">
                For questions, bug reports, or feature suggestions, please feel free to reach out. Your feedback is valuable for the continued improvement of this suite.
                <br><br>
                <strong>Contact:</strong> <a href="mailto:nittalaphaneendhar@gmail.com" class="support-email-link"><i class="fas fa-envelope"></i> nittalaphaneendhar@gmail.com</a>
            </p>

            <h3>Important Notice & Terms of Use</h3>
            <p class="mission-text">This tool is developed for educational and professional assessment purposes. For any serious or legal investigations, findings must be verified with judicially validated forensic tools. Always consult a certified digital forensics professional for official case work. By using this tool, you acknowledge its purpose and agree that the developer is not liable for any misuse or conclusions drawn from its results. You are responsible for your own actions and for complying with all applicable laws.</p>

        </div>
    </section>
</body>
</html>
